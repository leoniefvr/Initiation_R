---
title: "Exercice 3 : Statistiques descriptives"

code-fold: true
#code-tools: true

toc: true
toc-expand: 2
toc-depth: 2
number-sections: true

theme :
  light: flatly
  dark: darkly
---

Nous avons précédemment créé une base de travail propre permettant d'en retirer des statistiques descriptives. Celles-ci peuvent être calculées de façon à résumer le dataframe ou bien être intégrées à celui-ci via une variable supplémentaire.

# Commencer un programme

1.  Créer un nouveau programme puis l'enregister dans le projet créé précedemment.

2.  Charger les packages `dplyr`, `lubridate`, `tidyr`. 
    ```{r, eval=FALSE, echo=TRUE}
    #install.packages("ggplot") # Permet d'installer le package si besoin
    library(dplyr)
    library(lubridate) # Package de gestion des dates
    library(tidyr)
    library(Hmisc)
    ```

3.  Importer le dataframe précédemment enregistré au format `.xlsx`.
    ```{r, eval=FALSE, echo=TRUE}
    df_final <- read.xlsx("df.xlsx") # Chargement du dataframe
    ```
    
---

# Produire des statistiques descriptives pour résumer ses données

Nos données sont désormais propres, on peut donc commencer à faire des statistiques descriptives par catégorie.

1.  Connaitre les statistiques descriptives du dataframe avec `summary()`.
    ```{r, eval=FALSE, echo=TRUE}
    summary(df_final) # Permet de connaitre les statistiques descriptives des variables du dataframe
    ``` 

:::{.callout-warning}
La fonction `summary()` utilisée ici ne tient pas compte des pondérations. Les statistiques calculées à partir de la table de l'EEC doivent être pondérées.
:::

2.  A l'aide de pipe, faire la somme des effectifs par `trimestre` avec la fonction `summarise()`.

    ```{r, eval=FALSE, echo=TRUE}
    nb_individu <- df_final %>% 
      group_by(trimestre) %>% 
      summarise(effectifs = sum(POIDS)) 
    nb_individu
    ``` 

3.  Faire la somme des effectifs pondérés par `trimestre` avec la fonction `wtd.table()` du package `Hmisc`.

    ```{r, eval = FALSE, echo = TRUE}
    wtd.table(x = df_final$TRIM, weights = df_final$POIDS)
    ```

4.  Calculer les effectifs par modalités de la NAF en 88 postes, en utilisant la variable `Libellé` pour que les résultats soient lisibles.
    ```{r, eval=FALSE, echo=TRUE}
    nb_individu_NAF = df_final %>% 
      group_by(Libellé) %>% 
      summarise(effectifs = sum(POIDS))
    ``` 

---

#   Produire des statistiques descriptives dans un dataframe exhaustif 

Auparavant, nous avons vu comment résumer un dataframe à l'aide de `group_by()` et `summarise()`. On cherche désormais à ajouter des variables agrégées dans le dataframe sans perdre l'information au niveau individuel. 

1.  A partir du dataframe, ajouter une variable indiquant le nombre d'individus moyen par `trimestre` et `statut_activite_libelle` à l'aide de `mutate()`.
    ```{r, eval=FALSE, echo=TRUE}
   ... %>% 
      group_by(trimestre, statut_activite_libelle) %>% 
      mutate(sum_actif = sum(POIDS)) %>% 
      ungroup()
    ```

2.  Ajouter ensuite une variable du nombre total d'individus sur le trimestre.
    ```{r, eval=FALSE, echo=TRUE}
    ... %>% 
      group_by(trimestre) %>% 
      mutate(indiv_trim = sum(POIDS, na.rm = TRUE)) 
    ```

---

# Calculer le nombre de chômeurs par trimestre
1.  Créer un dataframe de résultat avec le nombre d'individus par `trimestre` et catégorie (`statut_activite_libelle`) avec la fonction `group_by()`. 
    ```{r, eval=FALSE, echo=TRUE}
chomage <- df_final %>% 
  group_by(trimestre, statut_activite_libelle) %>% 
  summarise(effectif_actif_trim = sum(POIDS, na.rm = TRUE)) 
    ``` 
    
2.  Calculer la part de chaque modalité par trimestre dans le nombre d'individus total du trimestre. 
    ```{r, eval=FALSE, echo=TRUE}
taux_chomage <- chomage %>% 
  group_by(trimestre) %>% 
  mutate(effectif_total = sum(effectif_actif_trim, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(taux = (effectif_actif_trim / effectif_total)*100)
    ``` 

---

# Mettre en forme ses résultats 

1.  Créer un dataframe avec les effectifs pondérés par statut d'activité et par trimestre avec en colonne le statut d'activité et en ligne le trimestre à l'aide de la fonction `pivot_wider()` (2 étapes). 
    ```{r, eval=FALSE, echo=TRUE}
df_eff_trim_activite <- df_final %>%
      group_by(trimestre, statut_activite_libelle) %>%
      summarise(effectifs = sum(POIDS))
    
df_pivot <- df_eff_trim_activite %>% 
      pivot_wider(names_from = c(statut_activite_libelle), values_from = c(effectifs))
    ```     

2.  Faire l'opération inverse à l'aide de la fonction `pivot_longer()`. 
    ```{r, eval=FALSE, echo=TRUE}
df_unpivot <- df_pivot %>% 
      pivot_longer(!c(trimestre), names_to = "statut_activite_libelle", values_to = "effectifs")
    ```

# Exporter ses résultats

1.  Télécharger et charger le package `xlsx`.
    ```{r, eval=FALSE, echo=TRUE}
#install.packages(xlsx) # Installation du package
library(xlsx) # Chargement du package
    ``` 

2.  Exporter le dataframe de statistique descriptive en `.xlsx` via la fonction `write_xlsx()`.
    ```{r, eval=FALSE, echo=TRUE}
write_xlsx(df_pivot, "resultat.xlsx") # Export du fichier excel
    ```

3.  Exporter plusieurs de ses résultats dans un seul fichier excel via `list()` et la fonction `write_xlsx()`.
    ```{r, eval=FALSE, echo=TRUE}
liste_onglet = list("statut_bit" = df_pivot,
                    "taux_chomage" = taux_chomage)
write_xlsx(liste_onglet, "resultat_total.xlsx") # Export du fichier excel
    ```

4.  Exporter ses résultats au format .csv avec `write_csv2()`.
    ```{r, eval=FALSE, echo=TRUE}
write.csv2()
    ```    


{"title":"Prise en main des donn√©es avec R","markdown":{"yaml":{"title":"Prise en main des donn√©es avec R","format":{"revealjs":{"slide-number":true,"footer":"Formation R - Dares"}},"editor":"visual"},"headingText":"Un rapide tour de table pour apprendre √† se conna√Ætre üôÇ","containsRefs":false,"markdown":"\n\n\n![](images/picture_1.jpg){fig-align=\"center\"}\n\n## Pourquoi R ? {.scrollable .smaller}\n\n<br>\n\n::: incremental\n-   ‚≠ê Open source et gratuit ‚≠ê\n-   üåê Harmonisation des langages au sein du SSP üåê\n-   üìà Analyse statistique avanc√©e üìà\n-   üå≥ Vaste √©cosyst√®me : extensions appel√©es \"packages\" (environ 20 000) üå≥\n-   ü§ù Communaut√© importante : facilit√©s pour trouver de l'aide ü§ù\n:::\n\n## Fonctionnement de R {.scrollable .smaller}\n\n<br>\n\n-   R est un environnement et un langage de programmation\n\n-   **Langage interpr√©t√©** : plus proche de notre langage que du langage machine\n\n-   **Langage compil√©** : les commandes tap√©es sont ex√©cut√©es directement\n\n-   **Langage objet** : on assigne une valeur √† quelque chose (`a <- 1`). Le symbole `<-` d√©signe l'assignation. Les objets sont pr√©sents dans la m√©moire vive de l'ordinateur (RAM) et l'assignation est une mani√®re d'y avoir acc√®s.\n\n‚õî**Attention :** le symbole `=` permet √©galement l'assignation, mais c'est une tr√®s mauvaise pratique de l'utiliser comme tel. Le symbole `=` est utilis√© de pr√©f√©rence pour renseigner la valeur des arguments des fonctions dans R. Vous pourrez n√©anmoins le rencontrer parfois comme mani√®re d'assigner. ‚õî\n\n## Les sp√©cificit√©s de R {.scrollable .smaller}\n\n<br>\n\nToutes les op√©rations sont enregistr√©es dans la m√©moire vive de l'ordinateur (RAM) :\n\n-   Cela peut poser des probl√®mes lors de la manipulation de donn√©es volumineuses.\n\n-   En SAS, la m√©moire RAM est sollicit√©e au minimum, des fichiers temporaires sont cr√©√©s.\n\n    |                                                                                     |\n    |------------------------------------------------------------------------|\n    | ‚õîImpossible de charger des donn√©es de 50GO avec un ordinateur ayant 32GO de RAM ‚õî |\n\n    **Attention :** R distingue les minuscules et les majuscules\n\n# Pr√©sentation de RStudio {.scrollable}\n\nRStudio est un environnement de d√©veloppement gratuit, libre et multiplateforme pour R, un langage de programmation utilis√© pour le traitement de donn√©es et l'analyse statistique.\n\n## La console {.scrollable .smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nLa **console** est un peu comme une calculatrice, elle ex√©cute mais **ne stocke pas** :\n\n-   Entrer les commandes\n\n-   Afficher les r√©sultats\n\n-   Afficher les messages d'erreur\n\n-   Ne stocke pas d'information\n\n<br>\n\n::: panel-tabset\n### Code {.scrollable}\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\n152/17\n```\n\n### R√©sultat {.scrollable}\n\n```{r, echo=FALSE}\n152/17\n```\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/console_R.jpeg)\n:::\n:::\n\n## L'environnement : {.scrollable .smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n<br>\n\n-   Etat de la m√©moire <br>\n-   R√©pertoire des donn√©es (stockage des objets) <br>\n-   Import de donn√©es en mode \"clic-bouton\"\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\ntest_environnement <- 1+1\n```\n:::\n\n::: {.column width=\"50%\"}\n![](images/console_R.jpeg)\n:::\n:::\n\n## Files, packages, help ... {.scrollable .smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n::: panel-tabset\n### Files {.scrollable}\n\n<br>\n\nObtenir le chemin √† la racine de ma working directory :\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\ngetwd()\n```\n\n<br>\n\nLa working directory est l'endroit o√π R lit et exporte par d√©faut les fichiers.\n\n### Plots {.scrollable}\n\n<br>\n\nFen√™tre d'affichage des graphiques :\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nplot(100)\n```\n\n### Packages {.scrollable}\n\n<br>\n\nPermet de voir les packages install√©s et charg√©s.\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nlibrary(\"existepas\")\n```\n\nPermet √©galement de les installer, les mettre √† jour et les charger en clic bouton.\n\n### Help {.scrollable}\n\n<br>\n\nPermet d'acc√©der √† la documentation des fonctions, ainsi qu'√† des exemples. Par exemple, je ne comprends pas la fonction `mean()` :\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nhelp(\"mean\")\n\n#ou\n\n?mean\n```\n\nLa documentation de la fonction s'affiche dans la fen√™tre Help.\n:::\n:::\n\n::: {.column width=\"50%\"}\n![](images/console_R.jpeg)\n:::\n:::\n\n## Utiliser l'aide {.scrollable .smaller}\n\n<br>\n\nLes fonctions des packages sont document√©es (de mani√®re in√©gale selon les packages...), et les **arguments** principaux de chaque fonction sont pr√©sent√©s dans l'aide, avec des exemples d'appel de la fonction. \n\n:::{.callout-tip title=\"Bonne pratique\"}\nLorsqu'on appelle une fonction dans R, R d√©tecte souvent automatiquement les arguments sans qu'on ait besoin de les nommer explicitement. Pour des raisons de lisibilit√© du code, il est recommand√© de les **nommer** syst√©matiquement.\n:::\n\n```{r, echo = TRUE}\n\nun_vecteur <- c(2, 3 ,9 , 45, 10)\n\n###Bonne pratique###\nmean(x = un_vecteur)\n\n###Mauvaise pratique###\nmean(un_vecteur)\n\n```\n\n## L'importance des packages {.scrollable .smaller}\n\nPour installer un package **dans la console**, on utilise :\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\ninstall.packages(\"dplyr\")\n```\n\n::: callout-tip\n## Bonne pratique\n\nNe pas laisser dans un script R (un fichier de code) l'instruction `install.packages()`, car lors de la transmission d'un script, la personne peut l'ex√©cuter par erreur alors que le package est d√©j√† install√©/√† jour sur son poste de travail.\n:::\n\nCela permet de charger (ou mettre √† jour) le package sur disque, depuis le **CRAN**. cette instruction n√©cessite donc une connexion √† internet.\n\nOn charge ensuite le package en m√©moire vive :\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nlibrary(\"dplyr\")\n```\n\n-   L'installation du package n'est √† ex√©cuter **qu'une seule fois**\n\n-   `install.packages()` permet aussi de r√©cup√©rer une version mise √† jour disponible sur le CRAN\n\n-   Le chargement en m√©moire vive (avec `library()`) doit √™tre effectu√© au d√©but de chaque session ouverte de R pour avoir acc√®s aux fonctionnalit√©s du package.\n\n:::{.callout-warning}\n‚õî Il existe un grand nombre de packages, mais certains sont **DEPRECATED** : leur utilisation n'est plus recommand√©e car ils ne sont plus mis √† jour et entretenus. \nPour assurer la p√©rennit√© d'un programme, (cha√Æne de production), il est recommand√© de n'utiliser que des packages largemment utilis√©s, r√©guli√®rement mis √† jour et recommand√© par la communaut√© (sur UtilitR par exemple).‚õî\n:::\n\n```{r}\nlibrary(dplyr)\n```\n\n## Travailler avec les projets R Studio : qu'est-ce que c'est ? {.scrollable .smaller}\n\nIl est recommand√© de regrouper les scripts et autres fichiers relatifs √† un m√™me \"projet statistique\" ou √† une m√™me cha√Æne de production √† l'aide d'un projet RStudio.\n\nUn **projet RStudio** permet de :\n\n-   **regrouper** les programmes et autres types de documents d'un m√™me projet ensemble ;\n\n-   faciliter le **suivi des modifcations**, notamment avec git ;\n\n-   favoriser la **reproductibilit√©** et la transmission des r√©glages li√©s √† un projet statistique.\n\nEn pratique, c'est un fichier `.Rproj` dans un dossier qui contient les programmes et les documents d'un m√™me projet statistique.\n\n## Travailler avec les projets R Studio : pourquoi ? {.scrollable .smaller}\n\nIl est recommand√© de travailler syst√©matiquement avec les projets RStudio. Un projet RStudio :\n\n-   **centralise** les √©l√©ments d'un projet statistique et permet d'y avoir acc√®s plus facilement avec les **chemins relatifs** : dans un programme, pour faire r√©f√©rence √† un document du projet RStudio, il suffit de renseigner son nom car le r√©pertoire de travail par d√©faut d'un projet est le dossier o√π se situe le fichier `.Rproj`.\n\n-   **am√©liore le travail collaboratif** : le principe des chemins relatifs rend le projet statistique ind√©pendant de l'arborescence de la machine sur laquelle il est h√©berg√©, et permet de d√©placer les fichiers plus facilement.\n\n-   **favorise la** **reproductibilit√©** du projet statistique (ou de d√©veloppement, d'un package par exemple). Il facilite √©galement le travail avec **Git**. Il est facile de relier un projet RStudio √† git pour travailler collaborativement.\n\n## Cr√©er un projet {.scrollable .smaller}\n\n::: columns\n::: {.column width=\"30%\"}\nPour cr√©er un projet sur RStudio :\n\n-   `File > New project`\n\n-   Il est possible de le cr√©er dans un nouveau dossier vide `New directory` ou dans un dossier existant `Existing directory`.\n\n-   Il est √©galement possible de le relier directement √† git `Version Control`.\n:::\n\n::: {.column width=\"60%\"}\n::: r-stack\n![](images/creer_projet_rstudio.png){.fragment width=\"550\" height=\"400\"}\n\n![](images/new_project_2.png){.fragment width=\"550\" height=\"400\"}\n\n![](images/new_project_3.png){.fragment width=\"550\" height=\"400\"}\n:::\n:::\n:::\n\n## Ouvrir un projet (source : UtilitR) {.scrollable .smaller}\n\n<br>\n\nLorsqu'on ouvre un projet RStudio :\n\n-   une nouvelle session R s'ouvre ;\n\n-   les sauvegardes de l'environnement sont ouvertes √† partir du fichier `.RData` si l'enregistrement a √©t√© activ√© (d√©conseill√©) ;\n\n-   la working directory est automatiquement d√©finie dans le dossier o√π se trouve le fichier `.Rproj` ;\n\n-   les documents ouverts au moment o√π le projet a √©t√© ferm√© pour la derni√®re fois sont restaur√©s, m√™me s'ils n'avaient pas √©t√© sauv√©s.\n\n## Fermer un projet (voir UtilitR) {.scrollable .smaller}\n\n<br>\n\nD'apr√®s la [documentation UtilitR sur les bonnes pratiques](https://www.book.utilitr.org/03_fiches_thematiques/fiche_rprojects) :\n\nIl est fortement conseill√© de d√©sactiver la sauvegarde du fichier `.RData` √† la fermeture du projet. Pour ce faire, il faut aller dans `Tools > Global Options` et rester dans l'onglet General. Chercher `Save workspace to .RData on exit:`, et choisir l'option Never.\n\n::: {.callout-tip title=\"Bonne pratique\"} Sauvegarder et recharger les donn√©es du projet avec le fichier `.RData` est une **tr√®s mauvaise pratique** en termes de reproductibilit√©. En effet, il se peut que les donn√©es sauvegard√©es dans le `.RData` aient subi des modifications non document√©es (par exemple via la console), ou que les instructions pr√©sentes dans les scripts du projet n'aient pas √©t√© ex√©cut√©es dans l'ordre. Dans ce cas, les donn√©es contenues dans le `.RData` peuvent ne pas √™tre coh√©rentes avec le projet, et en les utilisant vous risquez de ne pas obtenir les r√©sultats que vous voulez. :::\n\n## Fermer un projet (voir UtilitR) {.scrollable .smaller}\n\n::: r-stack\n![](images/new_script.png){.fragment width=\"550\" height=\"400\"}\n\n![](images/close_project_1.png){.fragment width=\"550\" height=\"400\"}\n\n![](images/close_project_2.png){.fragment width=\"550\" height=\"400\"}\n\n![](images/close_project_3.png){.fragment width=\"550\" height=\"400\"}\n:::\n\n## R√©diger un programme R : les bonnes pratiques {.scrollable .smaller}\n\n<br>\n\nComme nous l'avons vu, la console ne permet pas de stocker un programme. Pour r√©diger un programme r√©plicable, il faut cr√©er un **script R** (fichier `.R`).\n\nCette formation vise √† vous proposer quelques bonnes pratiques qui permettent la transmission des programmes R, notamment ceux des cha√Ænes de production.\n\nCes bonnes pratiques sont inspir√©es de [Chapitre 5 Boite √† outils \\| Guide des bonnes pratiques en R √† l'usage des statisticiens publics (utilitr.org)](https://www.pratiques.utilitr.org/boite-%C3%A0-outils.html).\n\n## R√©diger un programme R : les bonnes pratiques {.scrollable .smaller}\n\n::: panel-tabset\n### Nom\n\n-   Le **nom des scripts R** (fichiers .R) peut √™tre pr√©fix√© par sa **position dans la cha√Æne de production**.\n\n-   Le nom des scripts R peut √™tre suffix√© par le **mill√©sime de la production**, en cas de changement par rapport √† la derni√®re production et surtout en l'absence de versionage (git).\n\n-   Il est pr√©f√©rable que le nom des objets (script, variable dans le programme, tableau de donn√©es...) ne contiennent **pas de caract√®res sp√©ciaux, d'accent** et que les mots soient s√©par√©s par des **underscores**.\n\n-   Pour le nom des variables et tables manipul√©es dans le code, il est recommand√© d'utiliser des **substantifs informatifs**.\n\n-   Dans l'appel d'une **fonction**, il est recommand√© de **nommer les arguments** sp√©cifi√©s explicitement, pour favoriser la r√©plicabilit√© et la compr√©hension pour le lecteur.\n\n### Espace et indentation\n\n-   Il est recommand√© de retourner r√©guli√®rement √† la ligne pour rendre le code plus lisible.\n\n-   L'**indentation** n'est pas automatique en R (contrairement √† Python), il est recommand√© d'indenter le code pour am√©liorer sa lisibilit√©. Le raccourci `CTRL + I` permet de r√©indenter une s√©lection de lignes.\n\n-   Il est recommand√© d'ins√©rer des espaces entre les op√©rateurs : assignation `<-` ; comparaison `<` `>` `<=` `>=` `==` `!=` ; op√©rations `+` `-` `=`.\n\n-   Pas d'espace avant ou apr√®s les parenth√®ses et crochets.\n\n### Commentaire\n\n-   Il est recommand√© de **commenter** le code. Un commentaire d√©bute par `#` et se termine √† la fin de la ligne, contrairement √† SAS o√π il est possible d'encadrer du texte pour le commenter enti√®rement.\n\n-   Le commentaire doit √™tre clair et relativement court : il est pr√©f√©rable de bien nommer les objets de mani√®re informative, ainsi que les arguments des fonctions.\n\n-   Le script peut comporter des parties d√©limit√©es par des titres en commentaires.\n:::\n\n## Importer des donn√©es {.scrollable .smaller}\n\n```{r, echo = FALSE, include = FALSE, eval = TRUE}\n\n\n\n\n```\n\n\n```{r import_data, echo=FALSE, warning=FALSE, message=FALSE}\nlibrary(\"dplyr\")\n\n#EEC_2019 <- read.csv2(\"C:/Users/gaetan.guillermin/Documents/Formation/R/Dares/Data/FD_EEC_2019.csv\", \n               #header = TRUE, sep = \";\", quote = \"\\\"\", dec = \".\", fill = TRUE, comment.char = \"\")\n\nEEC_2019 <- read.csv2(\"C:/Users/leonie.fauvre/Documents/6_GITLAB DARES DSIDE/Formations_internes_R/formation_R_site/FD_EEC_2019.csv\", \n               header = TRUE, sep = \";\", quote = \"\\\"\", dec = \".\", fill = TRUE, comment.char = \"\")\n# \n# library(\"openxlsx\")\n# \n# EEC_AGE_RGP <- read.xlsx(\"C:/Users/leonie.fauvre/Documents/6_GITLAB DARES DSIDE/Formations_internes_R/formation_R_site/FD_EEC_AGE_RGP.xlsx\")\n# \n# library(\"haven\")\n# \n# EEC_2019_SAS <- read_sas(\"C:/Users/leonie.fauvre/Documents/6_GITLAB DARES DSIDE/Formations_internes_R/formation_R_site/FD_EEC_2019.sas7bdat\")\n\n```\n\n::: panel-tabset\n### Importer un fichier csv\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nEEC_2019 <- read.csv2(\"FD_EEC_2019.csv\", \n               header = TRUE, \n               sep = \";\", \n               quote = \"\\\"\", \n               dec = \".\", \n               fill = TRUE, \n               comment.char = \"\")\n```\n\n```{r, echo=TRUE, eval=TRUE}\nhead(EEC_2019, 5)\n```\n\n### Importer un fichier Excel\n\n```{r, echo=TRUE, results='hide', eval=TRUE}\nlibrary(\"openxlsx\")\n\nEEC_excel <- read.xlsx(\"FD_EEC_2019.xlsx\")\n```\n\n```{r, echo=TRUE, eval=TRUE}\nhead(EEC_excel, 5)\n```\n\n### Importer un fichier Sas\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nlibrary(\"haven\")\n\nEEC_2019_SAS <- read_sas(\"FD_EEC_2019.sas7bdat\")\n```\n\n:::\n\n## R : une logique vectorielle {.scrollable .smaller}\n\n<br>\n\nL'√©l√©ment de base de R est le vecteur `c()` :\n\n```{r, echo = TRUE}\nun_vecteur_numerique <- c(2, 6, 8, 1)\n```\n\nR utilise la logique de la **vectorisation** : les fonctions sont appliqu√©es √† *l'ensemble d'un vecteur* (ou matrice) plut√¥t que d'√™tre appliqu√©es successivement √† chacun des √©l√©ments de ce vecteur (ou de cette matrice). Cela permet une **acc√©l√©ration** du temps de calcul.\n\nPar exemple, pour obtenir le carr√© de chacun des √©l√©ments d'un vecteur :\n\n::: panel-tabset\n### Sans vectorisation\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nx <- 1:10\nfor (k in seq_along(x)) {\nx[k] <- x[k]**2\n}\n```\n\n### Avec vectorisation\n\nApplication de la fonction carr√©e au vecteur :\n\n```{r, echo=TRUE, results='hide', eval=FALSE}\nx <- 1:10\nx <- x**2\n```\n:::\n\n## Les objets √©l√©mentaires et leurs types {.scrollable .smaller}\n\n::: panel-tabset\n### Num√©rique {.smaller}\n\nIl existe deux types num√©riques en R :\n\n-   les entiers ;\n\n-   les flottants.\n\n```{r, echo=TRUE}\n\nnum <- 5\nclass(num)\n\n```\n\n<br>\n\n```{r, echo=TRUE}\nnum <- integer(5)\nclass(num)\n\n```\n\n### Les cha√Ænes de caract√®re {.smaller}\n\nUne cha√Æne de caract√®re est d√©limit√©e par des quotes ou des doubles quotes. Il est recommand√© d'utiliser les **doubles quotes** syst√©matiquement.\n\nLe nombre de caract√®res d'une cha√Æne de caract√®res est donn√© par la fonction `nchar()`.\n\nLa fonction `paste0()` permet de concat√©ner des cha√Ænes de caract√®res.\n\nüîçRemarque : l'anti slash en R permet de g√©rer les caract√®res sp√©ciaux, dans les chemins d'acc√®s aux donn√©es, il faut donc soit les remplacer par des **slashs**, soit les doubler.üîç\n\n```{r, echo=TRUE}\n\n#Cr√©ation d'une cha√Æne de caract√®res\nchaine <- \"Oui\"\n\n#Type de la variable chaine\nclass(chaine)\n```\n\n<br>\n\n```{r, echo=TRUE}\n#Nombre de caract√®res de la variable\nnchar(chaine)\n```\n\n<br>\n\n```{r, echo=TRUE}\n#Concat√©nation de plusieurs cha√Ænes de caract√®re\nprint(paste0(\"Les \", \"cha√Ænes \", \"de caract√®re \", \"peuvent √™tre concat√©n√©es.\"))\n```\n\n<br>\n\nüîçPour aller plus loin üîç le package `stringr` permet de traiter les cha√Ænes de caract√®re : mettre en majuscules, mettre en minuscules, extraire une sous-cha√Æne...\n\n### Les bool√©ens\n\nUn bool√©en peut valoir `TRUE` ou `FALSE` : c'est une variable qui indique si une condition logique est v√©rifi√©e.\n\n::: fragment\n```{r, echo = TRUE, results='hide', eval=FALSE}\n# Test de l'√©galit√©\nprint(1 == 2)\n```\n:::\n\n::: fragment\n```{r, echo = FALSE,eval=TRUE}\n# Test de l'√©galit√©\nprint(1 == 2)\n```\n:::\n\n<br>\n\n::: fragment\n```{r, echo = TRUE, results='hide', eval=FALSE}\na <- (\"Dares\" == \"Dares\")\nprint(a)\n```\n:::\n\n::: fragment\n```{r, echo = FALSE, eval=TRUE}\na <- (\"Dares\" == \"Dares\")\nprint(a)\n```\n:::\n\n<br>\n\n::: fragment\n```{r, echo = TRUE, results='hide', eval=FALSE}\n# Comparaison num√©rique\nprint(2 < 3)\n```\n:::\n::: fragment\n```{r, echo = FALSE, eval=TRUE}\n# Comparaison num√©rique\nprint(2 < 3)\n```\n:::\n\n<br>\n\n::: fragment\n```{r, echo = TRUE, results='hide', eval=FALSE}\nprint(4 >= 5)\n```\n:::\n\n::: fragment\n```{r, echo = FALSE, eval=TRUE}\nprint(4 >= 5)\n```\n:::\n\n<br>\n\n::: fragment\n```{r, echo = TRUE, results='hide', eval=FALSE}\nb <- 3 <= 2\nprint(b)\n```\n:::\n\n::: fragment\n```{r, echo = FALSE, eval=TRUE}\nb <- 3 <= 2\nprint(b)\n```\n:::\n\n<br>\n\n::: fragment\n```{r, echo = TRUE, results='hide', eval=FALSE}\n# Test de la diff√©rence\nprint(\"A\" != \"a\")\n```\n:::\n\n::: fragment\n```{r, echo = FALSE, eval=TRUE}\n# Test de la diff√©rence\nprint(\"A\" != \"a\")\n```\n:::\n\n‚ùó **Attention :** R est sensible √† la casse ‚ùó\n:::\n\n## Les structures de donn√©es de base en R {.scrollable .smaller}\n\n::: panel-tabset\n### Vecteurs\n\n<br>\n\nUn **vecteur** est une s√©quence ordonn√©e d'objets √©l√©mentaires de **m√™me type**. Les vecteurs ont un type (correspondant √† celui des objets qu'il contient) donn√© par la fonction `class()` et une longueur donn√©e par la fonction `length`.\n\n```{r, echo=TRUE}\nvecteur_num <- c(3, 18, 9)\nlength(vecteur_num)\n```\n\n<br>\n\n```{r, echo=TRUE}\nclass(vecteur_num)\n```\n\n### Listes\n\n<br>\n\nUne **liste** est une s√©quence ordonn√©e, √©ventuellement h√©t√©rog√®ne, d'objets de types quelconques.\n\nUne liste est toujours de type `list`, peu importe ce qui la compose.\n\n```{r, echo=TRUE}\n\nliste_divers <- list(\"A\", 7, TRUE)\nlength(liste_divers)\n```\n\n<br>\n\n```{r, echo=TRUE}\nclass(liste_divers)\n```\n\n<br>\n\n```{r, echo=TRUE}\n#Acc√©der aux √©l√©ments d'une liste\nprint(liste_divers[[1]])\n```\n:::\n\n# Manipuler des donn√©es : les avantages de dplyr\n\n## Data frames {.scrollable .smaller}\n\n<br>\n\nLe `data.frame` est un **tableau** sous forme d'une liste (classe list) de vecteurs qui repr√©sentent les colonnes. Les vecteurs doivent √™tre de la m√™me longueur, la longueur de chaque vecteur correspond au nombre de lignes/d'observations du tableau.\n\nPuisque **chaque colonne est un vecteur** :\n\n-   une colonne repr√©sente une variable d'un type unique ;\n\n-   une colonne a un nom, celui de la variable ;\n\n-   chaque colonne doit avoir la m√™me hauteur.\n\nLes dimensions du data.frame sont donn√©es par la fonction `dim()`.\n\n```{r, echo=TRUE}\n#Obtenir les dimensions du tableau de l'enqu√™te emploi en continu\ndim(EEC_2019)\n\n```\n\n## Op√©rations de base sur les data.frames : R base ou dplyr ? {.scrollable .smaller}\n\n<br>\n\nüëâ But : si vous rencontrez des syntaxes Rbase, les comprendre. Nous recommandons pour d√©buter d'utiliser plut√¥t les syntaxes `dplyr` pr√©sent√©es plus loin.\n\n‚ùì Pourquoi ‚ùì\n\nLa syntaxe de `dplyr` est √† notre avis plus lisible et intuitive pour s'initier √† R, et aussi largement utilis√©e par la communaut√© des utilisateurs de R, ce qui facilite le partage de solutions.\n\n:::{.callout-note}\nIl n'existe pas une mani√®re unique de programmer en R, et l'utilisation de Rbase pr√©sente aussi des avantages : la stabilit√© par exemple, la meilleure reproductibilit√© car n√©cessite moins de packages et de d√©pendances... \nCette formation propose une mani√®re de programme utilisant plut√¥t le `tidyverse`\n:::\n\n```{r, echo = FALSE, eval = TRUE}\nlibrary(forcats)\n\nEEC_ex <- EEC_2019 %>%\n  head(30) %>%\n  select(SEXE, ACTIF, COURED, AGE5, CSTOTR, NAFG004UN, AGE3, ANNEE, JOURTR) %>%\n  mutate(NAFG004UN = fct_recode(NAFG004UN,\n                                NULL = \"\")) %>%\n  mutate(SEXE = as.factor(SEXE)) %>%\n  mutate(SEXE = fct_recode(SEXE,\n                            \"Homme\" = \"1\",\n                            \"Femme\" = \"2\"))\n\n```\n\n## Op√©rations de base sur les data.frames : R base {.scrollable .smaller}\n\n::: panel-tabset\n### S√©lectionner des lignes\n\n-   Obtenir le nom des lignes :\n\n```{r, echo=TRUE}\nrownames(EEC_ex)\n```\n\n<br>\n\n-   S√©lectionner la 5√®me ligne :\n\n```{r, echo=TRUE}\nEEC_ex[5,]\n```\n\n<br>\n\n-   S√©lectionner les lignes 10 et 35 :\n\n```{r, echo=TRUE}\nEEC_ex[c(10,35),]\n```\n\n<br>\n\n-   S√©lectionner les lignes 3 √† 8 :\n\n```{r, echo=TRUE}\nEEC_ex[c(3:8),]\n```\n\n### S√©lectionner des colonnes\n\n-   Conna√Ætre le nom des colonnes/variables :\n\n```{r, echo=TRUE}\nnames(EEC_ex)\n```\n\n<br>\n\n-   S√©lectionner une colonne **solution 1** : la 3√®me colonne :\n\n```{r, echo=TRUE}\nEEC_ex[, 3]\n```\n\n<br>\n\n-   S√©lectionner une colonne **solution 2**, la variable ACTIF :\n\n```{r, echo=TRUE}\nEEC_ex[\"ACTIF\"]\n```\n\n<br>\n\n-   S√©lectionner une colonne **solution 3**, la variable ACTIF\n\n```{r, echo=TRUE}\nEEC_ex$ACTIF\n```\n\n<br>\n\n-   Conna√Ætre le **type** des variables :\n\n```{r, echo=TRUE}\nclass(EEC_ex$AGE3)\n```\n\n<br>\n\n-   S√©lectionner la 3√®me ligne et les colonnes SEXE et ACTIF :\n\n```{r, echo=TRUE}\nEEC_ex[3, c(\"SEXE\", \"ACTIF\")]\n```\n:::\n\n## Op√©rations de base sur les data.frames : convertir des colonnes {.scrollable .smaller}\n\n<br>\n\nConvertir une variable num√©rique en caract√®re :\n\n```{r, echo=TRUE}\nclass(EEC_ex$ANNEE)\nEEC_ex$ANNEE <- as.character(EEC_ex$ANNEE)\nclass(EEC_ex$ANNEE)\n```\n\n<br>\n\nConvertir une colonne caract√®re en num√©rique :\n\n```{r, echo=TRUE}\nEEC_ex$ANNEE <- as.numeric(EEC_ex$ANNEE)\nclass(EEC_ex$ANNEE)\n```\n\n## Les facteurs : un outil pour les variables qualitatives {.scrollable .smaller}\n\nLe type `factor` en R permet de manipuler des **variables qualitatives**.\n\nLe package `forcats` permet de traiter les facteurs : recoder les modalit√©s, les ordonner...\n\n::: panel-tabset\n### Convertir\n\n```{r, echo=TRUE}\nclass(EEC_2019$SEXE)\n\n#Conversion de la variable SEXE de num√©rique en facteur\nEEC_2019$SEXE <- as.factor(EEC_2019$SEXE)\n\nclass(EEC_2019$SEXE)\n```\n\n### Modalit√©s\n\nLa fonction `levels()` permet de conna√Ætre l'ensemble des **modalit√©s** existantes d'un facteur (m√™me si elles ne sont plus pr√©sentes dans les donn√©es apr√®s s√©lection des lignes).\n\n```{r, echo=TRUE}\nlevels(EEC_2019$SEXE)\n```\n\n### Recoder\n\nLa fonction `fct_recode()` permet de renommer les modalit√©s d'un facteur, avec la syntaxe suivante :\n\n```{r, echo = TRUE, eval = FALSE}\nnouvelle_variable <- fct_recode(ancienne_variable,\n                                \"Nouvelle_valeur1\" = \"Ancienne_valeur1\",\n                                \"Nouvelle_valeur2\" = \"Ancienne_valeur2\",\n                                NULL = \"Modalite_a_supprimer\")\n```\n\nExemple : Recodage des modalit√©s de la variable SEXE.\n\n```{r, echo = TRUE}\nlibrary(forcats)\n\nEEC_2019$SEXE <- fct_recode(EEC_2019$SEXE,\n                            \"Homme\" = \"1\",\n                            \"Femme\" = \"2\")\n\nlevels(EEC_2019$SEXE)\n```\n:::\n\n## Op√©rations de base sur les data.frames : les valeurs manquantes {.scrollable .smaller}\n\nLorsqu'une **valeur est manquante** dans une enqu√™te par exemple, elle figure sous forme de la modalit√© `NA`, \"Not Available\", qui existe pour tous les types de variables.\n\nSelon la mani√®re dont ces valeurs manquantes existent dans les donn√©es √† importer dans R, elles ne sont pas forc√©ment d√©tecter comme telles. Par exemple :\n\n```{r, echo = TRUE}\n\ntest_na <- as.data.frame(\n  list(\n  c(1, \".\", 3),\n  c(\"A\", \"E\", \".\")\n  )\n  )\n\nnames(test_na) <- c(\"Var1\", \"Var2\")\n\nprint(test_na)\n\n```\n\nIl faut les recoder en `NA` avec la fonction `fct_recode()` :\n\n```{r, echo = TRUE}\n\ntest_na$Var1 <- as.factor(test_na$Var1)\n\ntest_na$Var1 <- fct_recode(test_na$Var1,\n                           NULL = \".\")\n\nprint(test_na)\n```\n\n## Les dates sous R {.scrollable .smaller}\n\nLe format de **date** le plus courant en R est la classe `Date`. Elle correspond √† une distance par rapport √† une date origine, ce qui permet de faire des calculs (distance entre deux dates par exemple).\n\n::: panel-tabset\n### Cr√©er une date\n\nIl est possible de cr√©er une date √† partir d'une cha√Æne de carat√®re. *Le format standard est \"AAAA-MM-JJ\"*, mais il est possible de sp√©cifier un autre format.\n\n```{r, echo = TRUE}\n\ndate_1 <- as.Date(\"2023-01-24\")\n\ndate_2 <- as.Date(\"12/07/2022\", format = \"%d/%m/%Y\")\n\n```\n\n### Composants\n\nLe package `lubridate` permet de traiter les dates. Il n'est pas pr√©senter davantage ici, voici simplement comment il est possible d'acc√©der aux composants d'une date avec `lubridate` :\n\n```{r, echo = TRUE}\nlibrary(lubridate)\n\nyear(date_1)\nmonth(date_1)\nquarter(date_1)\nday(date_1)\n```\n\n### Intervalle\n\nAvec le type Date, vient la notion d'intervalle temporel, qui est √©galement un type de donn√©es √† part enti√®re. La fonction `interval()` permet de calculer des dur√©es.\n\n```{r, echo = TRUE}\nlibrary(lubridate)\n\ndate_1 <- as.Date(\"2023-01-24\")\n\ndate_2 <- as.Date(\"12/07/2022\", format = \"%d/%m/%Y\")\n\nintervalle <- interval(date_1, date_2)\nintervalle\nclass(intervalle)\n\n```\n:::\n\n## Tidyverse, dplyr et le pipe {.scrollable .smaller}\n\n<br>\n\nLa majorit√© des utilisateurs de R utilisent un ensemble de package contenu dans le `tidyverse` , qui propose des fonctions alternatives √† Rbase. Nous vous recommandons d'utiliser le tidyverse, et en particulier le package `dplyr`, pour r√©diger vos programmes.\n\nAvantages du tidyverse et de dplyr :\n\n-   plus lisible, plus proche d'un langage interpr√©t√© que R base ;\n\n-   utilis√© par la majorit√© des utilisateurs de R ;\n\n-   stable.\n\n```{r}\nlibrary(tidyverse)\n```\n\n## Le pipe {.scrollable .smaller}\n\n<br>\n\nPour encha√Æner diff√©rentes instructions sur un data.frame, on utilise le \"pipe\" : `%>%`, un op√©rateur qui permet de prendre ce qu'il y a √† gauche du pipe pour l'injecter en entr√©e (argument) dans la fonction √† droite du pipe.\n\n**Attention :** il est recommand√© de d√©finir un nouveau tableau pour enregistrer les op√©rations sur un data.frame.\n\nLes bonnes pratiques de r√©daction d'un code sont renseign√©es dans [UtilitR - Les bonnes pratiques](https://www.pratiques.utilitr.org/r%C3%A9diger-un-script-r.html)\n\n## S√©lectionner des colonnes {.scrollable .smaller}\n\n<br>\n\n**S√©lectionner** des colonnes par leur nom avec `select()` :\n\n```{r, echo = TRUE}\n#Les colonnes ann√©e et Age3\nnouveau_df_1 <- EEC_ex %>%\n  select(ANNEE, AGE3)\n\nhead(nouveau_df_1, 5)\n```\n\n. . .\n\n<br>\n\n**Supprimer** une colonne avec le `-` dans `select()` :\n\n```{r, echo = TRUE}\n#Toutes les colonnes sauf Age3\nnouveau_df_2 <- EEC_ex %>%\n  select(-AGE3)\n\nhead(nouveau_df_2, 5)\n```\n\n## Afficher les premi√®res lignes {.scrollable .smaller}\n\n<br>\n\nAvant de d√©buter une analyse, il est utile de **visualiser les premi√®res lignes** du tableau de donn√©es. C'est notamment tr√®s utile lorsque les donn√©es sont volumineuses et que l'affichage du tableau complet prend du temps.\n\n```{r, echo = TRUE}\n\nEEC_debut <- EEC_ex %>%\n  head(5)\nEEC_debut\n\n```\n\n## Filtrer des lignes {.scrollable .smaller}\n\n<br>\n\nPour filter des lignes selon une ou plusieurs conditions, on utilise la fonction `filter()` :\n\n::: panel-tabset\n### Egalit√©\n\n```{r, echo = TRUE}\n\nEEC_femme <- EEC_ex %>%\n  filter(SEXE == \"Femme\")\n\nhead(EEC_femme, 5)\n```\n\n### In√©galit√©\n\n```{r, echo = TRUE}\n\nEEC_moins_30 <- EEC_ex %>%\n  filter(AGE5 <= 30)\n\nhead(EEC_moins_30, 5)\n```\n\n### Diff√©rence\n\n```{r, echo = TRUE}\n\nEEC_hors_cadres <- EEC_ex %>%\n  filter(CSTOTR != 3)\n\nhead(EEC_hors_cadres, 5)\n```\n\n### Plusieurs conditions\n\n```{r, echo = TRUE}\n\n#Op√©rateur ET\nEEC_femme_moins_30 <- EEC_ex %>%\n  filter(SEXE == \"femme\" & AGE5 <= 30)\n\nhead(EEC_femme_moins_30, 5)\n\n#Op√©rateur OU\nEEC_femme_ou_cadre <- EEC_ex %>%\n  filter(SEXE == \"femme\" | CSTOTR == 3)\n\nhead(EEC_femme_ou_cadre, 5)\n```\n:::\n\n## Filtrer des lignes {.scrollable .smaller}\n\n<br>\n\n::: panel-tabset\n### Inclusion dans une liste\n\n```{r, echo = TRUE}\n\nEEC_hors_agr <- EEC_ex %>%\n  filter(NAFG004UN %in% c(\"ET\", \"EU\", \"EV\"))\n\nhead(EEC_hors_agr, 5)\n\n```\n\n### Valeurs manquantes\n\nPour tester si une valeur est manquante, il faut utiliser la fonction `is.na()`. Le test `variable == NA` renvoie une erreur.\n\nPour tester qu'une valeur est bien pr√©sente, c'est la condition `!(is.na(variable))`. la syntaxe `!()` signifie \"diff√©rent de\", c'est-√†-dire teste la condition contraire √† ce qui est renseign√© dans les parenth√®ses.\n\nUniquement les lignes pour lesquelles NAFG004UN est manquante :\n\n```{r, echo = TRUE}\nEEC_CSP_na <- EEC_ex %>%\n  filter(is.na(NAFG004UN))\n\nhead(EEC_CSP_na, 5)\n```\n\n<br>\n\nUniquement les lignes pour lesquelles NAFG004UN est renseign√©e :\n\n```{r, echo = TRUE}\nEEC_CSP_hors_na <- EEC_ex %>%\n  filter(!(is.na(NAFG004UN)))\n\nhead(EEC_CSP_hors_na, 5)\n```\n\n### Valeurs distinctes\n\nLa fonction `distinct()` permet de ne s√©lectionner qu'une seule occurence de chaque combinaison des variables signal√©es.\n\nOn ne souhaite qu'une seule occurence de chaque combinaison existant dans les donn√©es des variables ANNEE et TRIM :\n\n```{r, echo = TRUE}\nEEC_periode <- EEC_2019 %>%\n  distinct(ANNEE, TRIM)\n\nhead(EEC_periode, 5)\n```\n:::\n\n## Cr√©er une variable {.scrollable .smaller}\n\n::: panel-tabset\n### Avec if_else\n\n`if_else` est utilis√© pour renseigner une valeur si une condition est v√©rifi√©e, une autre sinon. La syntaxe est la suivante :\n\n```{r, echo = TRUE, eval = FALSE}\n\nmutate(nouvelle_variable = if_else(condition, valeur_condition_verifiee, valeur_sinon))\n\n```\n\n```{r, echo = TRUE}\nEEC_agr <- EEC_2019 %>%\n  mutate(agriculture = if_else(NAFG004UN == \"ES\", 1, 0))\n\nhead(EEC_agr, 5)\n```\n\n### Avec case_when\n\n`case_when` permet de cr√©er une variable qui prend diff√©rentes modalit√©s selon plusieurs conditions √©valu√©es successivement, selon la syntaxe suivante :\n\n```{r, echo = TRUE, eval = FALSE}\n\nmutate(nouvelle_variable = case_when(condition1 ~ valeur1,\n                                     condition2 ~ valeur2,\n                                     condition3 ~ valeur3,\n                                     TRUE ~ valeur_par_d√©faut))\n\n```\n\nLes conditions sont explor√©es successivement jusqu'√† ce qu'une d'entre elles donne `TRUE`, elles ne sont donc pas n√©cessairement exclusives l'une de l'autre. La derni√®re ligne ¬´ voiture balai ¬ª (qui n'est pas obligatoire) exploite cette fonctionnalit√© avec une condition toujours vraie qui pi√®ge tous les cas non explor√©s.\n\n### Avec une condition\n\nll est √©galement possible de cr√©er directement une variable de type **bool√©en** en mentionnat uniquement la condition :\n\n```{r, echo = TRUE, eval = FALSE}\nmutate(individu_cadre = (CSTOTR == 3))\n```\n\nLa nouvelle variable `individu_cadre` vaut `TRUE` lorsque CSTOTR vaut 3, `FALSE` sinon.\n:::\n\n## Modifier des variables {.scrollable .smaller}\n\n<br>\n\n::: panel-tabset\n### Renommer une variable\n\n```{r, echo = TRUE, eval = FALSE}\nrename(nouveau_nom_var1 = ancien_nom_var1,\n       nouveau_nom_var2 = ancien_nom_var2)\n```\n\n```{r, echo = TRUE}\n\nEEC_2 <- EEC_ex %>%\n  rename(AGE_3_classes = AGE3)\n\nhead(EEC_2, 5)\n```\n\n### Discr√©tiser une variable quanti\n\nAvec `cut()`, la borne inf√©rieure est exclue, la borne sup√©rieure est incluse.\n\n```{r, echo = TRUE}\nEEC_3 <- EEC_ex %>%\n  mutate(JOURTR_classe = cut(JOURTR, breaks = c(2,4)))\n\nhead(EEC_3, 5)\n```\n:::\n\n## Convertir des variables {.scrollable .smaller}\n\nLes fonctions de conversion peuvent √™tre appliqu√©es aux colonnes d'un data.frame. Il est conseill√© d'affecter √† chaque variable le type le plus proche de sa nature :\n\n```{r, echo = TRUE}\n#Conversion de la variable ENFRED en facteur et de la variable COURED en caract√®res :\n\nEEC_2019 <- EEC_2019 %>%\n  mutate(ENFRED = as.factor(ENFRED),\n         COURED = as.character(COURED))\n```\n\n<br>\n\n::: columns\n::: {.column width=\"50%\"}\n**ü§î Comment recoder ? ü§î**\n\n-   transformer les variables qualitatives en facteurs ;\n\n-   ordonner les modalit√©s pour les variables qualitatives ordinales ;\n\n-   convertir les variables num√©riques en num√©rique ;\n\n-   recoder les valeurs manquantes (par exemple les caract√®res vides) ;\n\n-   transformer les cha√Ænes de caract√®re en Date si n√©cessaire.\n:::\n\n::: {.column width=\"50%\"}\n‚ùì **Pourquoi recoder** ‚ùì\n\n-   pour r√©aliser des statistiques descriptives plus rapidement, par exemple avec la fonction summary ;\n\n-   pour que les fonctions √©conom√©triques d√©tectent une modalit√© de r√©f√©rence pertinente pour les variables ordinales ;\n\n-   pour tracer des s√©ries temporelles dans le cas des dates...\n:::\n:::\n\n# Statistiques descriptives\n\nüß∞ La boite √† outil du statisticien :\n\n## La fonction COUNT {.scrollable .smaller}\n\n<br>\n\n-   Connaitre le nombre de ligne d'un dataframe\n    -   On peut √©galement avoir cette information dans le panneau \"environnement\"\n-   Compter le nombre d'individu dans une table exhaustive\n    -   ‚õî Ne pas utiliser pour des donn√©es √©chantillon√©es ‚õî\n\n. . .\n\nNe pas calculer par exemple le nombre de ch√¥meurs au sens du BIT sans pond√©ration √† partir de l'EEC :\n\n```{r,  echo=TRUE}\nchomeurs <- EEC_2019 %>% \n  filter(ACTEU == \"2\") %>% \n  count()\n\nprint(paste0(\"Le nombre de ch√¥meurs au sens du BIT N'EST PAS \", as.character(chomeurs)))\n```\n\n## La fonction summarise {.scrollable .smaller}\n\n<br>\n\nCette fonction permet d'avoir un ensemble de **statistiques descriptives** : effectif, somme, moyenne, m√©diane, quantile, min, max...\n\nElle est fr√©quemment utilis√©e avec l'instruction `group_by()`, qui permet d'effectuer ces calculs au sein des groupes form√©s par les modalit√©s d'une variable.\n\n::: {.callout-tip title=\"Group_by\"}\nPour les habitu√©s de SQL, group_by n'est pas un mot cl√© mais une **vraie fonction R** avec une entr√©e et une sortie. Le r√©sultat est une table avec les m√™mes donn√©es mais un ¬´ index ¬ª en plus disant o√π sont les observations de chaque modalit√©. La pr√©sence de cet index change le fonctionnement de plusieurs fonctions de `dplyr` en les for√ßant √† travailler par morceau.\n:::\n\n## La fonction summarise {.scrollable .smaller}\n\n<br>\n\n::: panel-tabset\n### Effectif\n\nLa fonction `n()` permet d'obtenir les effectifs.\n\nCalcul du nombre de personnes de 30 ans ou moins :\n\n```{r, echo = TRUE}\neff_moins_30 <- EEC_2019 %>%\n  filter(AGE3 <= 30) %>%\n  summarise(eff_moins_30 = n())\neff_moins_30\n```\n\nCalcul du nombre de personnes par classe d'√¢ge en 3 classes :\n\n```{r, echo = TRUE}\neff_age_classe <- EEC_2019 %>%\n  group_by(AGE3) %>%\n  summarise(eff_age3 = n())\neff_age_classe\n```\n\nCalcul du nombre de personnes par SEXE :\n\n```{r, echo = TRUE}\neff_sexe <- EEC_2019 %>%\n  group_by(SEXE) %>%\n  summarise(eff_sexe = n())\neff_sexe\n```\n\n### Somme, moyenne\n\nLes fonctions `sum()` et `mean()` peuvent √™tre utilis√©es √©galement avec `summarise()`.\n\n::: callout-warning\n**Tout calcul impliquant un `NA` restitue un `NA`** : les op√©rations, les tests, les tris. Dans les calculs statistiques (par exemple avec les fonctions appel√©es par le `summarise` de dplyr utilis√© pour faire des r√©capitulations : comptages, totaux ou autres statistiques), il y a g√©n√©ralement un argument suppl√©mentaire `na.rm` (pour \"remove\") qui permet de ne pas tenir compte des valeurs manquantes, mais son positionnement par d√©faut est souvent √† \"faux\" (FALSE, ne pas enlever les valeurs manquantes du calcul).\n:::\n\n‚ö†Ô∏è **ATTENTION** ‚ö†Ô∏è Les valeurs manquantes sont le principal point d'incompatibilit√© avec SAS et leur traitement n√©cessite de redoubler d'attention quand on convertit un programme car le fonctionnement est radicalement diff√©rent en R.\n\nCalcul de la moyenne du nombre de jours travaill√©s par semaine par sexe :\n\n```{r, echo = TRUE}\nEEC_jourtr_sexe <- EEC_2019 %>%\n  group_by(SEXE) %>%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))\nEEC_jourtr_sexe\n\n```\n\n### Distribution\n\n`summarise()` est √©galement utile pour des statistiques de distribution.\n\nCalcul de statistiques de distribution du nombre de jours travaill√©s par semaine par classe d'√¢ge :\n\n```{r, echo = TRUE}\nEEC_jourtr_age <- EEC_2019 %>%\n  group_by(AGE3) %>%\n  summarise(min_jour_tr = min(JOURTR, na.rm = TRUE),\n            q1_jour_tr = quantile(JOURTR, na.rm = TRUE, probs = 0.25),\n            med_jour_tr = median(JOURTR, na.rm = TRUE),\n            q3_jour_tr = quantile(JOURTR, na.rm = TRUE, probs = 0.75),\n            max_jour_tr = max(JOURTR, na.rm = TRUE))\nEEC_jourtr_age\n```\n\n### Plusieurs variables\n\nIl est possible de renseigner plusieurs variables dans l'instruction `group_by()`. Les statistiques demand√©es dans `summarise()` sont alors calcul√©es au sein de chaque classe form√©e par le croisement des modalit√©s des deux variables.\n\n‚ö†Ô∏è **ATTENTION** ‚ö†Ô∏è la valeur par d√©faut de l'argument `drop_last` de la fonction `summarise()` est `TRUE`, ce qui implique que le dernier niveau de regroupement (la derni√®re variable renseign√©e dans le `group_by()`) est supprim√© √† l'issue de l'application de la fonction `summarise()`. Un `warning` le pr√©cise dans la console lorsque cette fonction est utilis√©e avec plusieurs variables de regroupement.\n\nCalcul de la moyenne de jours travaill√©s par semaine par groupe de sexe crois√© avec l'√¢ge en 3 classes :\n\n```{r, echo = TRUE}\nEEC_jourtr_sexe_age <- EEC_2019 %>%\n  group_by(SEXE, AGE3) %>%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))\nEEC_jourtr_sexe_age\n```\n:::\n\n## Regrouper par cat√©gorie {.scrollable .smaller}\n\nL'op√©rateur pipe `%>%` permet d'encha√Æner les op√©rations sur une table de donn√©es.\n\nIl faut faire attention √† cet encha√Ænement lorsqu'on utilise l'instruction `group_by`. Cette instruction peut √™tre utilis√©e avec d'autres fonctions de `dplyr` (`filter()` et `mutate()` par exemple), mais elle ne se comporte pas de la m√™me mani√®re avec toutes les fonctions. En effet, le dernier niveau de regroupement (la derni√®re variable renseign√©e dans le `group_by()`) est supprim√© √† l'issue de l'application de la fonction `summarise()`, tandis que ce n'est pas le cas avec les fonctions `mutate()` et `filter()`.\n\nAinsi, il est possible d'utiliser l'instruction `ungroup()` pour rem√©dier au regroupement des observations dans la suite des op√©rations sur la table.\n\n```{r, echo = TRUE}\nex_plusieurs_gpes <- EEC_2019 %>%\n  group_by(SEXE, AGE3) %>%\n  mutate(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %>%\n  ungroup() %>%\n  distinct(SEXE, moy_jour_tr, AGE3) %>%\n  group_by(SEXE) %>%\n  filter(moy_jour_tr == min(moy_jour_tr))\n\nex_plusieurs_gpes\n```\n\n## Trier ses donn√©es {.scrollable .smaller}\n\nLorsqu'on utilise un regroupement, le r√©sultat est tri√© en majeur selon ce regroupement. Si on souhaite effectuer un autre tri, il faut d√©clencher le tri avec la fonction `arrange()`. Le mot cl√© `desc` (malgr√© la syntaxe, ce n'est pas une fonction) permet de trier par ordre d√©croissant. Il est possible d'utiliser plusieurs colonnes pour le tri.\n\nüëÅÔ∏è‚Äçüó®Ô∏è **REMARQUE** üëÅÔ∏è‚Äçüó®Ô∏è Contrairement √† SAS o√π trier est la proc√©dure la plus utilis√©e, R se charge de lui m√™me de faire les tris dont il pourrait avoir besoin. Trier n'a g√©n√©ralement un sens que pour organiser la pr√©sentation de r√©sultats.\n\n```{r, echo = TRUE}\nex_arrange <- EEC_2019 %>%\n  select(SEXE, AGE3, JOURTR) %>%\n  group_by(SEXE, AGE3) %>%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %>%\n  arrange(moy_jour_tr)\nex_arrange\n```\n\nREMARQUE : Contrairement √† SAS o√π trier est la proc√©dure la plus utilis√©e, R se charge de lui m√™me de faire les tris dont il pourrait avoir besoin. Trier n'a g√©n√©ralement un sens que pour organiser la pr√©sentation de r√©sultats.\n\n### Connaitre le num√©ro de ligne\n\nLa fonction `row_number()` permet de conna√Ætre l'ordre de classement de l'observation dans la table.\n\nLes fonctions `first()` et `last()` permettent de r√©cup√©rer respectivement la premi√®re et la derni√®re observation d'un groupe.\n\n```{r, echo = TRUE}\nex_arrange_2 <- EEC_2019 %>%\n  select(SEXE, AGE3, JOURTR) %>%\n  group_by(SEXE, AGE3) %>%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %>%\n  arrange(moy_jour_tr) %>%\n  mutate(numero = row_number())\nex_arrange_2\n```\n\n## Travailler avec des donn√©es pond√©r√©es {.scrollable .smaller}\n\nLe package `Hmisc` permet de traiter des donn√©es pond√©r√©es.\n\nDes fonctions utilisant des pond√©rations se trouvent dans le package Hmisc, elles utilisent un argument suppl√©mentaire `weights` qui permet de passer la colonne contenant les pond√©rations. Il s'agit de :\n\n-   `wtd.mean` : la moyenne\n\n-   `wtd.var` : la variance (en d√©duire l'√©cart type si besoin)\n\n-   `wtd.quantile` : un quantile, plusieurs algorithmes sont impl√©ment√©s, mais aucun ne correspond √† ce que fait SAS.\n\n```{r, echo = TRUE}\ndf <- data.frame(age = c(20, 30, 40, 50, 60), poids=c(1, 1, 1, 1, 3))\n\nlibrary(Hmisc)\n\nnew_df <- df %>% \n  summarise(quartile1 = wtd.quantile(age,w=poids,probs=.25),\n            mediane = wtd.quantile(age,w=poids,probs=.5),\n            moyenne = wtd.mean(age,w=poids))\n```\n\n## Concat√©nations {.scrollable .smaller}\n\n::: panel-tabset\n### Des lignes\n\n<br>\n\nMettre les lignes d'une table derri√®re les lignes d'une autre : la fonction `bind_rows()`\n\n-   Les deux listes de colonnes peuvent ne pas √™tre strictement identiques : les donn√©es ne sont mises bout √† bout que si les noms des colonnes co√Øncident, sinon des valeurs manquantes sont g√©n√©r√©es.\n\n-   Les colonnes peuvent √™tre dans un **ordre diff√©rent** dans les deux tables, la fonction se charge de les r√©ordonner.\n\n-   Par contre **une colonne de m√™me nom doit avoir le m√™me type dans les deux tables** ou la concat√©nation ne se fait pas.\n\n### Des colonnes\n\n<br>\n\nMettre les colonnes d'une table √† cot√© des colonnes d'une autre : la fonction `bind_cols()`.\n\n-   Le **nombre de lignes doit co√Øncider** dans les deux tables : c'est un garde-fou contre les erreurs de manipulation, car la fonction ne r√©alise pas une jointure mais une simple juxtaposition.\n\n-   L'usage de cette fonction est donc **plus rare** et limit√© aux situations o√π on est absolument s√ªr d'avoir le bon nombre de lignes et des donn√©es qui sont rang√©es de la m√™me fa√ßon dans les deux tables.\n:::\n\n## Jointures {.scrollable .smaller}\n\n::: panel-tabset\n### A gauche/√† droite\n\n<br>\n\n::: columns\n::: {.column width=\"70%\"}\n```{r, echo = TRUE, eval = FALSE}\n\ntable_jointe <- table_1 %>%\n  left_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                            \"var3_table1\" = \"var4_table2\"))\n\n```\n:::\n\n::: {.column width=\"30%\"}\n![](images/left_join.png)\n:::\n:::\n\n### Interne\n\n<br>\n\n::: columns\n::: {.column width=\"70%\"}\n```{r, echo = TRUE, eval = FALSE}\n\ntable_jointe <- table_1 %>%\n  inner_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                             \"var3_table1\" = \"var4_table2\"))\n\n```\n:::\n\n::: {.column width=\"30%\"}\n![](images/inner_join.png)\n:::\n:::\n\n### Externe\n\n<br>\n\n::: columns\n::: {.column width=\"70%\"}\n```{r, echo = TRUE, eval = FALSE}\n\ntable_jointe <- table_1 %>%\n  full_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                            \"var3_table1\" = \"var4_table2\"))\n\n```\n:::\n\n::: {.column width=\"30%\"}\n![](images/full_join.png)\n:::\n:::\n\n### Anti_join\n\n<br>\n\nPour r√©cup√©rer les observations de la table de gauche qui sont absentes de la table de droite.\n\n::: columns\n::: {.column width=\"70%\"}\n```{r, echo = TRUE, eval = FALSE}\n\ntable_jointe <- table_1 %>%\n  anti_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                            \"var3_table1\" = \"var4_table2\"))\n\n```\n:::\n\n::: {.column width=\"30%\"}\n![](images/anti_join.png)\n:::\n:::\n:::\n\n## Transpositions {.scrollable .smaller}\n\n<br>\n\nPour pivoter des donn√©es, il est possible d'utiliser les fonctions `pivot_longer()` et `pivot_wider()` du package `tidyr`.\n\nPar exemple, pour la fonction `pivot_longer()`, la syntaxe est la suivante : `pivot_longer(cols = c(\"Var_1_pivotee\", \"Var_2_pivotee\"), names_to = c(\"nom_de_la_nouvelle_colonne\"))`\n\n```{r, echo = TRUE}\n\nlibrary(tidyr)\n\nex_pivot <- EEC_2019 %>%\n  select(SEXE, AGE3, JOURTR) %>%\n  group_by(SEXE, AGE3) %>%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE),\n            med_jour_tr = median(JOURTR, na.rm = TRUE)) %>%\n  ungroup() %>%\n  pivot_longer(cols = c(\"moy_jour_tr\", \"med_jour_tr\"), names_to = c(\"indicateur\"))\nex_pivot\n\n```\n\n## Graphiques avec plot {.scrollable .smaller}\n\nVoici une pr√©sentation succinte de quelques fonctions usuelles de Rbase permettant de faire des graphiques :\n\n::: panel-tabset\n### Barplot\n\n```{r, echo = TRUE}\n\nex_barplot <- EEC_2019 %>%\n  select(SEXE, JOURTR) %>%\n  group_by(SEXE) %>%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))\n\nbarplot(ex_barplot$moy_jour_tr, legend.text = ex_barplot$SEXE)\n\n```\n\n### Hist\n\n```{r, echo = TRUE}\nex_hist <- EEC_2019 %>%\n  select(JOURTR)\n\nhist(ex_hist$JOURTR)\n\n```\n\n### Plot\n\n```{r, echo = TRUE}\ndata(iris)\nplot(x = iris$Sepal.Length, y = iris$Sepal.Width)\n\n```\n:::\n\n## Ressources sur ggplot2 {.scrollable .smaller}\n\n<br>\n\nLe package `ggplot2` permet de cr√©er des graphiques tr√®s souplement, en modifiant une grande partie des param√®tres. Il ne fait pas l'objet d'une pr√©sentation ici, mais pour s'y former, la fiche UtilitR sur le sujet [UtilitR-Ggplot2](https://www.book.utilitr.org/03_fiches_thematiques/fiche_graphiques) , ainsi que le site [R-graph-gallery](https://r-graph-gallery.com/) vous sont recommand√©s.\n\nEnfin, pour avoir des recommandations sur les diff√©rents types de visualisation possibles selon la nature des variables √† repr√©senter, le site [From Data to Viz](https://www.data-to-viz.com/) est tr√®s utile.\n\n# Exporter des donn√©es {.scrollable .smaller}\n\n::: panel-tabset\n\n### En Excel : UtilitR {.scrollable .smaller}\n\nPour l'exportation de donn√©es au format **xlsx**, le package `openxlsx` est √† privil√©gier car il pr√©sente de multiples options tr√®s pratiques pour personnaliser les exports.\n\nLes [deux vignettes](https://ycphs.github.io/openxlsx/articles/Introduction.html) du package sur ce sujet apportent quelques exemples des potentialit√©s d'√©criture de classeurs xlsx. La premi√®re pr√©sente notamment l'utilisation de la fonction `write.xlsx()` et la seconde illustre quelques possibilit√©s autour de la fonction `writeData()`.\n\n```{r, echo = TRUE}\n\nlibrary(dplyr)\n\neff_par_age <- EEC_2019 %>%\n  group_by(AGE3) %>%\n  summarise(eff_par_age = n())\neff_par_age\n\nlibrary(openxlsx)\n\nwrite.xlsx(eff_par_age, file = \"mon_export.xlsx\", asTable = TRUE)\n\n```\n\n### En CSV\n\n<br>\n\n```{r, echo = TRUE}\n\neff_par_age <- EEC_2019 %>%\n  group_by(AGE3) %>%\n  summarise(eff_par_age = n())\neff_par_age\n\nwrite.csv(x = eff_par_age, file = \"monFichier.csv\")\n```\n\n\n### En PNG\n\n<br>\n\nPour exporter un graphique :\n\n```{r, echo = TRUE}\n\npng(filename = \"mon_graphique.png\", width = 500, height = 300)\nhist(EEC_2019$JOURTR)\ndev.off()\n\n```\n\n\n:::\n\n# Aide pour R {.scrollable .smaller}\n\n-   cheatsheets disponibles sur UtilitR √† avoir en local\n\n-   utilitR\n\n-   stackoverflow\n\n-   issues github sur le sujet\n\n-   forums internes : tchap Outils Stats v2, Langage R, Dares entraide Git et R\n\n-   vos coll√®gues\n\n-   nous\n\n-   des ateliers th√©matiques\n\n# Bibliographie\n\n"},"formats":{"revealjs":{"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"slides.html"},"language":{},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.2.269","auto-stretch":true,"title":"Prise en main des donn√©es avec R","editor":"visual","slideNumber":true,"footer":"Formation R - Dares"}}}}
[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "exercice_1.html",
    "href": "exercice_1.html",
    "title": "Exercice 1 : Débuter avec R",
    "section": "",
    "text": "1 Débuter avec R\n\nOuvrir R et créer un nouveau script R.\nEnregistrer ce nouveau fichier dans un dossier puis vérifier que le fichier est bien enregistré.\nFermer R puis ouvrir à nouveau votre fichier. Un programme R est suffixé par .R.\nInstaller et charger le package dplyr avec la fonction library.\n\n\nCode\ninstall.packages(\"dplyr\") # Installation du package\nlibrary(\"dplyr\") # Chargement du package\n\n\nVérifier la bonne installation et le bon chargement du package à l’aide des informations de la console ou des commandes library() et search().\n\n\nCode\nlibrary() # Permet de connaitre les packages installés\nsearch() # Permet de connaitre  les packages chargés pour la session de travail\n\n\n\n\n\n\n2 Créer des objets\n\nAssigner à x la valeur 5, vérifier que ceci a bien été fait à l’aide de la console ou de l’environnement.\n\n\nCode\nx &lt;- 5 # Assignation à x la valeur 5\nprint(x) # Affichage de la valeur de x \nx # Affichage de la valeur de x \n\n\n\nLorsque l’on créé des objets, on va toujours leur assigner un nom, ceci permet de les garder en mémoire vive et d’y avoir accès pendant la session de travail. On peut ensuite retrouver ses objets dans l’environnement. Pour tous les nouveaux objets que nous allons créer, vous devrez leur assigner un nom.\n\n\n\n\n\n\nCaution\n\n\n\nCes objets sont stockés en mémoire vive pour la durée de la session de travail R. Cela signifie qu’ils sont définitivement perdus lorsque RStudio est fermé. Pour conserver des objets en dur sur le disque, il faut utiliser des fonctions d’export.\n\n\n\nCréer un vecteur de 5 prénoms nommé vec_prenom avec c().\n\n\nCode\nvec_prenom &lt;- c(\"prenom_1\", \"prenom_2\", \"prenom_3\", \"prenom_4\", \"prenom_5\") # Création        d'un vecteur \n\n\nAfficher le type du vecteur vec_prenom avec la fonction class().\n\n\nCode\nclass(vec_prenom) # Affichage du type de l'objet vec_prenom\n\n\nAurait-il été possible d’ajouter un élément numérique dans ce vecteur ?\nCréer une liste de 5 prénoms nommée liste_prenom avec list().\n\n\nCode\nliste_prenom &lt;- list(\"prenom_1\", \"prenom_2\", \"prenom_3\", \"prenom_4\", \"prenom_5\") #     v      Création d'une liste \n\n\nAfficher le type de liste_prenom :\n\n\nCode\nclass(liste_prenom) #Affichage du type de l'objet liste_prenom\n\n\nAurait-il été possible d’ajouter un élément numérique dans ce vecteur ? Et un booléen ?\nCréer une matrice avec 2 lignes et 3 colonnes remplie de nombres avec matrix.\n\n\nCode\nmatrice &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3)\n\n\nCréer un vecteur de nombres allant de 1 à 20 par pas de 2 à l’aide de la fonction seq().\n\n\nCode\nvec_1_20 &lt;- seq(from = 1, to = 20, by =2)\n\n\n\n\n\n\n3 Les dataframes\n\nCréer un dataframe nommé df avec 3 lignes et 2 colonnes prenom et age avec la fonction data.frame(). Remplir les variables avec les valeurs de votre choix.\n\n\nCode\ndf &lt;- data.frame(prenom = c(\"prenom_1\", \"prenom_2\", \"prenom_3\"),\n                 age = c(52, 25, 10))\n\n\nAnalyser la classe et le type des objets que l’on vient de créer avec la fonction str().\n\n\nCode\nstr(object = df) # Permet de connaitre la structure d'un objet\nclass(df) # Permet de connaitre le type d'un objet \n\n\nConnaitre le nom des colonnes du dataframe avec colnames(), le nombre de lignes avec nrow(), de colonnes avec ncol().\n\n\nCode\ncolnames(df) # Permet de connaitre le nom des colonnes d'un data frame\nnrow(df) # Permet de connaitre le nombre de lignes d'un data frame\nncol(df) # Permet de connaitre le nombre de colonnes d'un data frame\n\n\nAfficher les valeurs de la variable prenom du dataframe créé avec $.\n\n\nCode\ndf$prenom # Affichage (sélection) de la colonne prenom du data frame\n\n\nRécupérer le vecteur prenom à partir du dataframe et le stocker dans un nouvel objet\n\n\nCode\nnouvel_objet &lt;- df$prenom # Récupérer le vecteur prenom à partir du dataframe\n\n\nDe quel type est ce nouvel objet ?\n\n\n\n4 Changer le type d’un objet\n\nPasser d’une liste à un vecteur avec unlist() et d’un vecteur à une liste avec as.list().\n\n\nCode\ndelister &lt;- unlist(liste_prenom)\nlister &lt;- as.list(vec_prenom) # Passage à un type liste\n\n\nPasser d’une matrice à un dataframe avec as.data.frame().\n\n\nCode\ndataframer &lt;- as.data.frame(matrice) # Passage à un dataframe\n\n\n\n\n\n\n5 Nettoyer son environnement\n\nSupprimer les objets que l’on vient de créer à l’aide de rm(). Les objets sont supprimés de l’environnement et ne sont donc plus accessibles du tout.\n\n\nCode\nrm(df) # suppression de son environnement le dataframe df\n\n\nLibérer sa mémoire à l’aide de la fonction gc(). Ceci permet de libérer de la mémoire lorsque l’on travaille avec des bases volumineuses.\n\n\nCode\ngc() # Permet de libérer la mémoire inutilisée\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNormalement, la gestion de la mémoire vive en R est automatique : lorsqu’un objet n’est plus accessible car on l’a retiré de l’environnement, R le supprime de la mémoire vive automatiquement. Néanmoins, lorsqu’une base de données très volumineuses est traitée, utiliser gc() permet de forcer la libération de la mémoire vive complète avant de lancer une nouvelle ligne de programmation.\n\n\n\n\n\n6 Connaitre son dataframe\nOn va utiliser ici le dataframe iris qui est disponible en libre accès depuis R. Il suffit de taper iris dans R pour le voir apparaitre. On va donc l’assigner à un nom pour le garder en mémoire et pouvoir faire nos manipulations sur celui-ci.\n\n\n\n\n\n\nDataframe iris\n\n\n\n\n\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n\n\n\n\n\n\nAssigner la table iris au nom df_iris.\n\n\nCode\ndf_iris &lt;- iris # Assignation de iris au nom df_iris\n\n\nSe renseigner sur l’objet iris :\n\n\nLe type de l’objet avec class()\nLe nom des variables avec colnames()\nLe type de variable avec str()\n\n\nCode\nclass(df_iris) # Type de l'objet\ncolnames(df_iris) # Nom des variables\nstr(df_iris) # Types des variables\n\n\n\n\nConnaitre le nombre de lignes avec nrow(), de colonnes avec ncol(), d’observations avec count().\n\n\nCode\nncol(df_iris) # Nombre de colonnes\nnrow(df_iris) # Nombre de lignes\ncount(df_iris) # Nombre d'observations = nombre de lignes\n\n\nConnaitre les modalités de la variable Species à l’aide de la fonction unique(). On cherche à avoir les modalités distinctes ici.\n\n\nCode\nunique(df_iris$Species) # Permet d'obtenir les modalités distinctes de la variable Species\n\n\n\n\n\n\n7 Manipuler son dataframe\nOn va désormais utiliser les pipes (`%&gt;%``) pour manipuler et transformer ses données. A chaque question, vous devez créer un nouvel objet auquel vous assignez un nom.\n\nA l’aide d’un pipe (%&gt;%) et de la fonction select(), créer un dataframe avec une seule variable du dataframe iris.\n\n\nCode\ndf_1_variable &lt;- df_iris %&gt;% \n  select(Species)\n\n\nA l’aide d’un pipe (%&gt;%) et de la fonction mutate(), créer une variable correspondant à la somme des variables Sepal.Length et Sepal.Width.\n\n\nCode\ndf_somme_iris &lt;- df_iris %&gt;% \n  mutate(somme = Sepal.Length + Sepal.Width)\n\n\nA l’aide d’un pipe (%&gt;%) et de la fonction filter(), garder uniquement les observations pour lesquelles Petal.Width est supérieur à 0.2.\n\n\nCode\ndf_grande_petale &lt;- df_iris %&gt;% \n  filter(Petal.Width &gt; 0.2) # Seules les lignes où Petal.Width &gt; 0.2 sont conservées dans df_grande_petale\n\n\nA l’aide d’un pipe (%&gt;%) et de la fonction rename(), renommer la variableSpeciesparespece`.\n\n\nCode\ndf_renomme &lt;- df_iris %&gt;% \n  rename(espece = Species) # Remplacement du nom de la variable Species par espece\n\n\nA l’aide d’un pipe (%&gt;%) et de la fonction mutate(), passer la variable Sepal.Length au format caractère.\n\n\nCode\ndf_sepal_char &lt;- df_iris %&gt;% \n  mutate(Sepal.Length = as.character(Sepal.Length)) # Passage de la variable Sepal.Length au format caractère\n\n\nA l’aide d’un pipe (%&gt;%) et de la fonction arrange(), trier le dataframe en fonction de Sepal.Length, par ordre décroissant.\n\n\nCode\ndf_sepal_tri &lt;- df_iris %&gt;% \n  arrange(desc(Sepal.Length)) # Tri du dataframe en fonction de la variable Sepal.Length, par ordre décroissant\n\n\n\n\n\n\n8 Enchainer les pipes\n\nEn partant du dataframe iris, créer un dataframe nommé df_pipe en enchaînant les étapes ci-dessous.\n\nGarder uniquement les observations pour les Species setosa et versicolor\nRenommer la variable Petal.Length par longueur_petale\nCréer la variable long_large correspondant au produit de Sepal.Length et Sepal.Width\nRetirer la variable Petal.Width\nTrier en fonction de longueur_petale\n\n\n\nCode\ndf_pipe &lt;- iris %&gt;% \n  filter(Species %in% c(\"setosa\", \"versicolor\")) %&gt;% \n  rename(longueur_petale = Petal.Length) %&gt;% \n  mutate(long_large = Sepal.Length * Sepal.Width) %&gt;% \n  select(-Petal.Width) %&gt;% \n  arrange(longueur_petale)\n\n\nEn partant du dataframe iris, créer un dataframe nommé df_final en enchaînant les étapes ci-dessous.\n\nRenommer les variables pour qu’elles soient en minuscules avec les fonctions rename_all() et tolower()\nNe garder que les observations pour lesquelles Sepal.Length est différent de 5.8\nCréer une variable oui_non égale à 1 lorsque Sepal.Width égale à 3.5 et 0 sinon à l’aide de la fonction ifelse()\n\n\n\nCode\ndf_final &lt;- iris %&gt;%\n  rename_all(tolower) %&gt;% \n  filter(sepal.length != 5.8) %&gt;% \n  mutate(oui_non = ifelse(sepal.width == 3.5, 1, 0))\n\n\nEnregister son fichier, nettoyer son environnement et passer à l’exercice 2.",
    "crumbs": [
      "Exercice 1"
    ]
  },
  {
    "objectID": "slides.html#un-rapide-tour-de-table-pour-apprendre-à-se-connaître",
    "href": "slides.html#un-rapide-tour-de-table-pour-apprendre-à-se-connaître",
    "title": "Prise en main des données avec R",
    "section": "Un rapide tour de table pour apprendre à se connaître 🙂",
    "text": "Un rapide tour de table pour apprendre à se connaître 🙂",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#pourquoi-r",
    "href": "slides.html#pourquoi-r",
    "title": "Prise en main des données avec R",
    "section": "Pourquoi R ?",
    "text": "Pourquoi R ?\n\n\n\n⭐ Open source et gratuit ⭐\n🌐 Harmonisation des langages au sein du SSP 🌐\n📈 Analyse statistique avancée 📈\n🌳 Vaste écosystème : extensions appelées “packages” (environ 20 000) 🌳\n🤝 Communauté importante : facilités pour trouver de l’aide 🤝",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#quel-avantages-de-r-pour-la-dares",
    "href": "slides.html#quel-avantages-de-r-pour-la-dares",
    "title": "Prise en main des données avec R",
    "section": "Quel avantages de R pour la Dares ?",
    "text": "Quel avantages de R pour la Dares ?\n\nHomogénéiser les pratiques au sein du SSP\nRenforcer l’attractivité de la Dares, dans un contexte où les sortants d’école sont plus fréquemment formés à R/Python\nDévelopper certains modèles dits Big Data et Machine learning très récents implémentés sous R et Python : l’exemple de Jocas à la Dares sous Python et des recommandations du GT Big Data\nProfiter de l’intégration de R à d’autres outils comme Git, qui facilitent le travail collaboratif",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#fonctionnement-de-r",
    "href": "slides.html#fonctionnement-de-r",
    "title": "Prise en main des données avec R",
    "section": "Fonctionnement de R",
    "text": "Fonctionnement de R\n\n\nR est un environnement et un langage de programmation\nLangage interprété : plus proche de notre langage que du langage machine\nLangage compilé : les commandes tapées sont exécutées directement\nLangage objet : on assigne une valeur à quelque chose (a &lt;- 1). Le symbole &lt;- désigne l’assignation. Les objets sont présents dans la mémoire vive de l’ordinateur (RAM) et l’assignation est une manière d’y avoir accès.\n\n⛔Attention : le symbole = permet également l’assignation, mais c’est une très mauvaise pratique de l’utiliser comme tel. Le symbole = est utilisé de préférence pour renseigner la valeur des arguments des fonctions dans R. Vous pourrez néanmoins le rencontrer parfois comme manière d’assigner. ⛔",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#les-spécificités-de-r",
    "href": "slides.html#les-spécificités-de-r",
    "title": "Prise en main des données avec R",
    "section": "Les spécificités de R",
    "text": "Les spécificités de R\n\nToutes les opérations sont enregistrées dans la mémoire vive de l’ordinateur (RAM) :\n\nCela peut poser des problèmes lors de la manipulation de données volumineuses.\nEn SAS, la mémoire RAM est sollicitée au minimum, des fichiers temporaires sont créés.\n\n\n\n\n\n\n⛔Impossible de charger des données de 50GO avec un ordinateur ayant 32GO de RAM ⛔\n\n\n\nAttention : R distingue les minuscules et les majuscules",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#le-travail-en-mémoire-vive-à-la-dares",
    "href": "slides.html#le-travail-en-mémoire-vive-à-la-dares",
    "title": "Prise en main des données avec R",
    "section": "Le travail en mémoire vive à la Dares",
    "text": "Le travail en mémoire vive à la Dares\nLa mémoire vive en R est donc utilisée à la fois pour charger les données à manipuler et pour réaliser les calculs demandés.\nLa Dares reçoit des données administratives parfois conséquentes, plus volumineuses que la mémoire vive des ordinateurs portables fournis. Dans ce cas, différentes solutions existent et se développent au sein du SSP :\n\nCréer un échantillon des données à la réception, mais cela peut poser problème pour travailler sur des sous-populations ;\nLe format de données compressées parquet, qui peut être manipulé avec les packages arrow et duckdb, se développe à l’Insee ;\nLorsque les données sont beaucoup plus volumineuses que la mémoire vive et doivent être traitées avec un serveur, des solutions telles que le calcul distribué avec Spark peuvent être envisagées. Un atelier d’exemple de manipulation des données MiDAS avec Spark sous R et sous CASD est prévu dans l’année pour illustrer ces solutions.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#la-console",
    "href": "slides.html#la-console",
    "title": "Prise en main des données avec R",
    "section": "La console",
    "text": "La console\n\n\nLa console est un peu comme une calculatrice, elle exécute mais ne stocke pas :\n\nEntrer les commandes\nAfficher les résultats\nAfficher les messages d’erreur\nNe stocke pas d’information\n\n\n\nCodeRésultat\n\n\n\n152/17\n\n\n\n\n\n[1] 8.941176",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#lenvironnement",
    "href": "slides.html#lenvironnement",
    "title": "Prise en main des données avec R",
    "section": "L’environnement :",
    "text": "L’environnement :\n\n\n\n\nEtat de la mémoire \nRépertoire des données (stockage des objets) \nImport de données en mode “clic-bouton”\n\n\ntest_environnement &lt;- 1+1",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#files-packages-help",
    "href": "slides.html#files-packages-help",
    "title": "Prise en main des données avec R",
    "section": "Files, packages, help …",
    "text": "Files, packages, help …\n\n\n\nFilesPlotsPackagesHelp\n\n\n\nObtenir le chemin à la racine de ma working directory :\n\ngetwd()\n\n\nLa working directory est l’endroit où R lit et exporte par défaut les fichiers.\n\n\n\nFenêtre d’affichage des graphiques :\n\nplot(100)\n\n\n\n\nPermet de voir les packages installés et chargés.\n\nlibrary(\"existepas\")\n\nPermet également de les installer, les mettre à jour et les charger en clic bouton.\n\n\n\nPermet d’accéder à la documentation des fonctions, ainsi qu’à des exemples. Par exemple, je ne comprends pas la fonction mean() :\n\nhelp(\"mean\")\n\n#ou\n\n?mean\n\nLa documentation de la fonction s’affiche dans la fenêtre Help.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#utiliser-laide",
    "href": "slides.html#utiliser-laide",
    "title": "Prise en main des données avec R",
    "section": "Utiliser l’aide",
    "text": "Utiliser l’aide\n\nLes fonctions des packages sont documentées (de manière inégale selon les packages…), et les arguments principaux de chaque fonction sont présentés dans l’aide, avec des exemples d’appel de la fonction.\n\n\n\n\n\n\n\nBonne pratique\n\n\nLorsqu’on appelle une fonction dans R, R détecte souvent automatiquement les arguments sans qu’on ait besoin de les nommer explicitement. Pour des raisons de lisibilité du code, il est recommandé de les nommer systématiquement.\n\n\n\n\n\nun_vecteur &lt;- c(2, 3 ,9 , 45, 10)\n\n###Bonne pratique###\nmean(x = un_vecteur)\n\n[1] 13.8\n\n###Mauvaise pratique###\nmean(un_vecteur)\n\n[1] 13.8",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#limportance-des-packages",
    "href": "slides.html#limportance-des-packages",
    "title": "Prise en main des données avec R",
    "section": "L’importance des packages",
    "text": "L’importance des packages\nPour installer un package dans la console, on utilise :\n\ninstall.packages(\"dplyr\")\n\n\n\n\n\n\n\nBonne pratique\n\n\nNe pas laisser dans un script R (un fichier de code) l’instruction install.packages(), car lors de la transmission d’un script, la personne peut l’exécuter par erreur alors que le package est déjà installé/à jour sur son poste de travail.\n\n\n\nCela permet de charger (ou mettre à jour) le package sur disque, depuis le CRAN. cette instruction nécessite donc une connexion à internet.\nOn charge ensuite le package en mémoire vive :\n\nlibrary(\"dplyr\")\n\n\nL’installation du package n’est à exécuter qu’une seule fois\ninstall.packages() permet aussi de récupérer une version mise à jour disponible sur le CRAN\nLe chargement en mémoire vive (avec library()) doit être effectué au début de chaque session ouverte de R pour avoir accès aux fonctionnalités du package.\n\n\n\n\n\n\n\nWarning\n\n\n⛔ Il existe un grand nombre de packages, mais certains sont DEPRECATED : leur utilisation n’est plus recommandée car ils ne sont plus mis à jour et entretenus. Pour assurer la pérennité d’un programme, (chaîne de production), il est recommandé de n’utiliser que des packages largemment utilisés, régulièrement mis à jour et recommandé par la communauté (sur UtilitR par exemple).⛔",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#travailler-avec-les-projets-r-studio-quest-ce-que-cest",
    "href": "slides.html#travailler-avec-les-projets-r-studio-quest-ce-que-cest",
    "title": "Prise en main des données avec R",
    "section": "Travailler avec les projets R Studio : qu’est-ce que c’est ?",
    "text": "Travailler avec les projets R Studio : qu’est-ce que c’est ?\nIl est recommandé de regrouper les scripts et autres fichiers relatifs à un même “projet statistique” ou à une même chaîne de production à l’aide d’un projet RStudio.\nUn projet RStudio permet de :\n\nregrouper les programmes et autres types de documents d’un même projet ensemble ;\nfaciliter le suivi des modifcations, notamment avec git ;\nfavoriser la reproductibilité et la transmission des réglages liés à un projet statistique.\n\nEn pratique, c’est un fichier .Rproj dans un dossier qui contient les programmes et les documents d’un même projet statistique.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#travailler-avec-les-projets-r-studio-pourquoi",
    "href": "slides.html#travailler-avec-les-projets-r-studio-pourquoi",
    "title": "Prise en main des données avec R",
    "section": "Travailler avec les projets R Studio : pourquoi ?",
    "text": "Travailler avec les projets R Studio : pourquoi ?\nIl est recommandé de travailler systématiquement avec les projets RStudio. Un projet RStudio :\n\ncentralise les éléments d’un projet statistique et permet d’y avoir accès plus facilement avec les chemins relatifs : dans un programme, pour faire référence à un document du projet RStudio, il suffit de renseigner son nom car le répertoire de travail par défaut d’un projet est le dossier où se situe le fichier .Rproj.\naméliore le travail collaboratif : le principe des chemins relatifs rend le projet statistique indépendant de l’arborescence de la machine sur laquelle il est hébergé, et permet de déplacer les fichiers plus facilement.\nfavorise la reproductibilité du projet statistique (ou de développement, d’un package par exemple). Il facilite également le travail avec Git. Il est facile de relier un projet RStudio à git pour travailler collaborativement.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#créer-un-projet",
    "href": "slides.html#créer-un-projet",
    "title": "Prise en main des données avec R",
    "section": "Créer un projet",
    "text": "Créer un projet\n\n\nPour créer un projet sur RStudio :\n\nFile &gt; New project\nIl est possible de le créer dans un nouveau dossier vide New directory ou dans un dossier existant Existing directory.\nIl est également possible de le relier directement à git Version Control.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#ouvrir-un-projet-source-utilitr",
    "href": "slides.html#ouvrir-un-projet-source-utilitr",
    "title": "Prise en main des données avec R",
    "section": "Ouvrir un projet (source : UtilitR)",
    "text": "Ouvrir un projet (source : UtilitR)\n\nLorsqu’on ouvre un projet RStudio :\n\nune nouvelle session R s’ouvre ;\nles sauvegardes de l’environnement sont ouvertes à partir du fichier .RData si l’enregistrement a été activé (déconseillé) ;\nla working directory est automatiquement définie dans le dossier où se trouve le fichier .Rproj ;\nles documents ouverts au moment où le projet a été fermé pour la dernière fois sont restaurés, même s’ils n’avaient pas été sauvés.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#fermer-un-projet-voir-utilitr",
    "href": "slides.html#fermer-un-projet-voir-utilitr",
    "title": "Prise en main des données avec R",
    "section": "Fermer un projet (voir UtilitR)",
    "text": "Fermer un projet (voir UtilitR)\n\nD’après la documentation UtilitR sur les bonnes pratiques :\nIl est fortement conseillé de désactiver la sauvegarde du fichier .RData à la fermeture du projet. Pour ce faire, il faut aller dans Tools &gt; Global Options et rester dans l’onglet General. Chercher Save workspace to .RData on exit:, et choisir l’option Never.\n::: {.callout-tip title=“Bonne pratique”} Sauvegarder et recharger les données du projet avec le fichier .RData est une très mauvaise pratique en termes de reproductibilité. En effet, il se peut que les données sauvegardées dans le .RData aient subi des modifications non documentées (par exemple via la console), ou que les instructions présentes dans les scripts du projet n’aient pas été exécutées dans l’ordre. Dans ce cas, les données contenues dans le .RData peuvent ne pas être cohérentes avec le projet, et en les utilisant vous risquez de ne pas obtenir les résultats que vous voulez. :::",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#fermer-un-projet-voir-utilitr-1",
    "href": "slides.html#fermer-un-projet-voir-utilitr-1",
    "title": "Prise en main des données avec R",
    "section": "Fermer un projet (voir UtilitR)",
    "text": "Fermer un projet (voir UtilitR)",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#rédiger-un-programme-r-les-bonnes-pratiques",
    "href": "slides.html#rédiger-un-programme-r-les-bonnes-pratiques",
    "title": "Prise en main des données avec R",
    "section": "Rédiger un programme R : les bonnes pratiques",
    "text": "Rédiger un programme R : les bonnes pratiques\n\nComme nous l’avons vu, la console ne permet pas de stocker un programme. Pour rédiger un programme réplicable, il faut créer un script R (fichier .R).\nCette formation vise à vous proposer quelques bonnes pratiques qui permettent la transmission des programmes R, notamment ceux des chaînes de production.\nCes bonnes pratiques sont inspirées de Chapitre 5 Boite à outils | Guide des bonnes pratiques en R à l’usage des statisticiens publics (utilitr.org).",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#rédiger-un-programme-r-les-bonnes-pratiques-1",
    "href": "slides.html#rédiger-un-programme-r-les-bonnes-pratiques-1",
    "title": "Prise en main des données avec R",
    "section": "Rédiger un programme R : les bonnes pratiques",
    "text": "Rédiger un programme R : les bonnes pratiques\n\nNomEspace et indentationCommentaire\n\n\n\nLe nom des scripts R (fichiers .R) peut être préfixé par sa position dans la chaîne de production.\nLe nom des scripts R peut être suffixé par le millésime de la production, en cas de changement par rapport à la dernière production et surtout en l’absence de versionage (git).\nIl est préférable que le nom des objets (script, variable dans le programme, tableau de données…) ne contiennent pas de caractères spéciaux, d’accent et que les mots soient séparés par des underscores.\nPour le nom des variables et tables manipulées dans le code, il est recommandé d’utiliser des substantifs informatifs.\nDans l’appel d’une fonction, il est recommandé de nommer les arguments spécifiés explicitement, pour favoriser la réplicabilité et la compréhension pour le lecteur.\n\n\n\n\nIl est recommandé de retourner régulièrement à la ligne pour rendre le code plus lisible.\nL’indentation n’est pas automatique en R (contrairement à Python), il est recommandé d’indenter le code pour améliorer sa lisibilité. Le raccourci CTRL + I permet de réindenter une sélection de lignes.\nIl est recommandé d’insérer des espaces entre les opérateurs : assignation &lt;- ; comparaison &lt; &gt; &lt;= &gt;= == != ; opérations + - =.\nPas d’espace avant ou après les parenthèses et crochets.\n\n\n\n\nIl est recommandé de commenter le code. Un commentaire débute par # et se termine à la fin de la ligne, contrairement à SAS où il est possible d’encadrer du texte pour le commenter entièrement.\nLe commentaire doit être clair et relativement court : il est préférable de bien nommer les objets de manière informative, ainsi que les arguments des fonctions.\nLe script peut comporter des parties délimitées par des titres en commentaires.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#importer-des-données",
    "href": "slides.html#importer-des-données",
    "title": "Prise en main des données avec R",
    "section": "Importer des données",
    "text": "Importer des données\n\nImporter un fichier csvImporter un fichier ExcelImporter un fichier Sas\n\n\n\nEEC_2019 &lt;- read.csv2(\"FD_EEC_2019.csv\", \n               header = TRUE, \n               sep = \";\", \n               quote = \"\\\"\", \n               dec = \".\", \n               fill = TRUE, \n               comment.char = \"\")\n\n\nhead(EEC_2019, 5)\n\n  ANNEE TRIM CATAU2010R METRODOM TYPMEN7 AGE3 AGE5 COURED ENFRED NFRRED SEXE\n1  2019    1          1        1       1   50   60      2      2      1    2\n2  2019    2          1        1       3   50   60      1      2      1    1\n3  2019    2          1        1       3   50   60      1      2      1    2\n4  2019    3          1        1       3   50   60      1      2      1    1\n5  2019    3          1        1       3   50   60      1      2      1    2\n  ACTEU ACTEU6 ACTIF ACTOP AIDFAM ANCCHOM ANCINACT CONTACT CREACCP DEM DISPOC\n1     3      6     2     2     NA      NA       NA      NA      NA   0     NA\n2     1      1     1     1     NA      NA       NA      NA      NA   0     NA\n3     3      6     2     2      2      NA        8      NA      NA   0     NA\n4     1      1     1     1     NA      NA       NA      NA      NA   0     NA\n5     3      6     2     2      2      NA        8      NA      NA   0     NA\n  GARDEB HALOR INSCONT MRA MRB MRBBIS MRC MRD MRDBIS MRE MREC MRF MRG MRGBIS\n1     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n2     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n3     NA     2      NA  NA  NA     NA  NA  NA     NA  NA    2  NA  NA     NA\n4     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n5     NA     2      NA  NA  NA     NA  NA  NA     NA  NA    2  NA  NA     NA\n  MRH MRI MRJ MRK MRL MRM MRN MRO MRPASSA MRPASSB MRPASSC MRS NONDIC NREC NRECA\n1  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n2  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n3  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n4  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n5  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n  NRECB OCCREF OFFICC OFFRE PASTRA PASTRB PASTRF PERCREV RABS RAISNREC RAISNSOU\n1    NA      1     NA    NA     NA     NA     NA      NA   NA       NA       NA\n2    NA      2     NA    NA     NA     NA     NA      NA   NA       NA       NA\n3    NA      1     NA    NA      2      2      2      NA   NA       NA        5\n4    NA      2     NA    NA      1     NA      1       1    8       NA       NA\n5    NA      1     NA    NA      2      2      2      NA   NA       NA        5\n  RAISPAS SOU SOUA SOUB SOUC SOUSEMPL STCHE TEMP TRAREF TYPCONT TYPCONTB CHPUB\n1      NA  NA   NA   NA   NA       NA    NA    2     NA      NA       NA    NA\n2      NA   2    2    2   NA       NA    NA   NA      1      NA       NA     1\n3      NA   2   NA   NA    2       NA    NA   NA      2      NA       NA    NA\n4      NA   2    2    2   NA        3    NA   NA      2      NA       NA     1\n5      NA   2   NA   NA    2       NA    NA   NA      2      NA       NA    NA\n  CSE CSER CSP CSTOT CSTOTR FONCTC NAFG004UN NAFG010UN NAFG017UN NAFG021UN\n1  NA   NA  NA    86      8     NA                                        \n2  64    6  64    64      6     NA        EU        FZ        FZ         F\n3  NA   NA  NA    77      7     NA                                        \n4  64    6  64    64      6     NA        EU        FZ        FZ         F\n5  NA   NA  NA    77      7     NA                                        \n  NAFG038UN NAFG088UN PUB3FP QPRC STC RDET STAT2 STATOEP STATUT STATUTR TITC\n1                  NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n2        FZ        43      4    9   3   NA     2      35     35       5   NA\n3                  NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n4        FZ        43      4    9   3   NA     2      35     35       5   NA\n5                  NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n  CSTMN CSTPLC DISPPLC DUHAB GARDEA HHC6 HORAIC RAISON RAISTP STMN STPLC TPPRED\n1    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n2    NA     NA      NA     1     NA    1      3     NA      5    2     2      2\n3    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n4    NA     NA      NA     1     NA    1      3     NA      5    2     2      2\n5    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n  TXTPPRED ANCENTR4 SITANT AAC CSA NAFANT NAFANTG004N DIP11 CSTOTPRM IDENTM\n1       NA       NA     NA   2   0      0          00    70       86      1\n2        1        4      5  NA  NA     NA                50       64      2\n3       NA       NA     NA   1  54     43          EU    70       64      2\n4        1        4      5  NA  NA     NA                50       64      3\n5       NA       NA     NA   1  54     43          EU    70       64      3\n    EXTRIAN EMPNBH HREC HHCE HPLUSA JOURTR NBTOTE\n1 107.74972     NA   NA   NA     NA     NA     NA\n2  46.17385      1   NA    1     NA      1     NA\n3  46.17385     NA   NA   NA     NA     NA     NA\n4  44.32930      0   NA    1     NA      1     NA\n5  44.32930     NA   NA   NA     NA     NA     NA\n\n\n\n\n\nlibrary(\"openxlsx\")\n\nEEC_excel &lt;- read.xlsx(\"FD_EEC_2019.xlsx\")\n\n\nhead(EEC_excel, 5)\n\n  ANNEE TRIM CATAU2010R METRODOM TYPMEN7 AGE3 AGE5 COURED ENFRED NFRRED SEXE\n1  2019    1          1        1       1   50   60      2      2      1    2\n2  2019    2          1        1       3   50   60      1      2      1    1\n3  2019    2          1        1       3   50   60      1      2      1    2\n4  2019    3          1        1       3   50   60      1      2      1    1\n5  2019    3          1        1       3   50   60      1      2      1    2\n  ACTEU ACTEU6 ACTIF ACTOP AIDFAM ANCCHOM ANCINACT CONTACT CREACCP DEM DISPOC\n1     3      6     2     2     NA      NA       NA      NA      NA   0     NA\n2     1      1     1     1     NA      NA       NA      NA      NA   0     NA\n3     3      6     2     2      2      NA        8      NA      NA   0     NA\n4     1      1     1     1     NA      NA       NA      NA      NA   0     NA\n5     3      6     2     2      2      NA        8      NA      NA   0     NA\n  GARDEB HALOR INSCONT MRA MRB MRBBIS MRC MRD MRDBIS MRE MREC MRF MRG MRGBIS\n1     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n2     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n3     NA     2      NA  NA  NA     NA  NA  NA     NA  NA    2  NA  NA     NA\n4     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n5     NA     2      NA  NA  NA     NA  NA  NA     NA  NA    2  NA  NA     NA\n  MRH MRI MRJ MRK MRL MRM MRN MRO MRPASSA MRPASSB MRPASSC MRS NONDIC NREC NRECA\n1  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n2  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n3  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n4  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n5  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n  NRECB OCCREF OFFICC OFFRE PASTRA PASTRB PASTRF PERCREV RABS RAISNREC RAISNSOU\n1    NA      1     NA    NA     NA     NA     NA      NA   NA       NA       NA\n2    NA      2     NA    NA     NA     NA     NA      NA   NA       NA       NA\n3    NA      1     NA    NA      2      2      2      NA   NA       NA        5\n4    NA      2     NA    NA      1     NA      1       1    8       NA       NA\n5    NA      1     NA    NA      2      2      2      NA   NA       NA        5\n  RAISPAS SOU SOUA SOUB SOUC SOUSEMPL STCHE TEMP TRAREF TYPCONT TYPCONTB CHPUB\n1      NA  NA   NA   NA   NA       NA    NA    2     NA      NA       NA    NA\n2      NA   2    2    2   NA       NA    NA   NA      1      NA       NA     1\n3      NA   2   NA   NA    2       NA    NA   NA      2      NA       NA    NA\n4      NA   2    2    2   NA        3    NA   NA      2      NA       NA     1\n5      NA   2   NA   NA    2       NA    NA   NA      2      NA       NA    NA\n  CSE CSER CSP CSTOT CSTOTR FONCTC NAFG004UN NAFG010UN NAFG017UN NAFG021UN\n1  NA   NA  NA    86      8     NA      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;\n2  64    6  64    64      6     NA        EU        FZ        FZ         F\n3  NA   NA  NA    77      7     NA      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;\n4  64    6  64    64      6     NA        EU        FZ        FZ         F\n5  NA   NA  NA    77      7     NA      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;\n  NAFG038UN NAFG088UN PUB3FP QPRC STC RDET STAT2 STATOEP STATUT STATUTR TITC\n1      &lt;NA&gt;        NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n2        FZ        43      4    9   3   NA     2      35     35       5   NA\n3      &lt;NA&gt;        NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n4        FZ        43      4    9   3   NA     2      35     35       5   NA\n5      &lt;NA&gt;        NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n  CSTMN CSTPLC DISPPLC DUHAB GARDEA HHC6 HORAIC RAISON RAISTP STMN STPLC TPPRED\n1    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n2    NA     NA      NA     1     NA    1      3     NA      5    2     2      2\n3    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n4    NA     NA      NA     1     NA    1      3     NA      5    2     2      2\n5    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n  TXTPPRED ANCENTR4 SITANT AAC CSA NAFANT NAFANTG004N DIP11 CSTOTPRM IDENTM\n1       NA       NA     NA   2   0      0           0    70       86      1\n2        1        4      5  NA  NA     NA        &lt;NA&gt;    50       64      2\n3       NA       NA     NA   1  54     43          EU    70       64      2\n4        1        4      5  NA  NA     NA        &lt;NA&gt;    50       64      3\n5       NA       NA     NA   1  54     43          EU    70       64      3\n       EXTRIAN EMPNBH HREC HHCE HPLUSA JOURTR NBTOTE\n1  107.7497222   &lt;NA&gt;   NA &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;\n2 46.173848259      1   NA    1   &lt;NA&gt;      1   &lt;NA&gt;\n3 46.173848259   &lt;NA&gt;   NA &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;\n4 44.329297911      0   NA    1   &lt;NA&gt;      1   &lt;NA&gt;\n5 44.329297911   &lt;NA&gt;   NA &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;\n\n\n\n\n\nlibrary(\"haven\")\n\nEEC_2019_SAS &lt;- read_sas(\"FD_EEC_2019.sas7bdat\")",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#r-une-logique-vectorielle",
    "href": "slides.html#r-une-logique-vectorielle",
    "title": "Prise en main des données avec R",
    "section": "R : une logique vectorielle",
    "text": "R : une logique vectorielle\n\nL’élément de base de R est le vecteur c() :\n\nun_vecteur_numerique &lt;- c(2, 6, 8, 1)\n\nR utilise la logique de la vectorisation : les fonctions sont appliquées à l’ensemble d’un vecteur (ou matrice) plutôt que d’être appliquées successivement à chacun des éléments de ce vecteur (ou de cette matrice). Cela permet une accélération du temps de calcul.\nPar exemple, pour obtenir le carré de chacun des éléments d’un vecteur :\n\nSans vectorisationAvec vectorisation\n\n\n\nx &lt;- 1:10\nfor (k in seq_along(x)) {\nx[k] &lt;- x[k]**2\n}\n\n\n\nApplication de la fonction carrée au vecteur :\n\nx &lt;- 1:10\nx &lt;- x**2",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#les-objets-élémentaires-et-leurs-types",
    "href": "slides.html#les-objets-élémentaires-et-leurs-types",
    "title": "Prise en main des données avec R",
    "section": "Les objets élémentaires et leurs types",
    "text": "Les objets élémentaires et leurs types\n\nNumériqueLes chaînes de caractèreLes booléens\n\n\nIl existe deux types numériques en R :\n\nles entiers ;\nles flottants.\n\n\nnum &lt;- 5\nclass(num)\n\n[1] \"numeric\"\n\n\n\n\nnum &lt;- integer(5)\nclass(num)\n\n[1] \"integer\"\n\n\n\n\nUne chaîne de caractère est délimitée par des quotes ou des doubles quotes. Il est recommandé d’utiliser les doubles quotes systématiquement.\nLe nombre de caractères d’une chaîne de caractères est donné par la fonction nchar().\nLa fonction paste0() permet de concaténer des chaînes de caractères.\n🔍Remarque : l’anti slash en R permet de gérer les caractères spéciaux, dans les chemins d’accès aux données, il faut donc soit les remplacer par des slashs, soit les doubler.🔍\n\n#Création d'une chaîne de caractères\nchaine &lt;- \"Oui\"\n\n#Type de la variable chaine\nclass(chaine)\n\n[1] \"character\"\n\n\n\n\n#Nombre de caractères de la variable\nnchar(chaine)\n\n[1] 3\n\n\n\n\n#Concaténation de plusieurs chaînes de caractère\nprint(paste0(\"Les \", \"chaînes \", \"de caractère \", \"peuvent être concaténées.\"))\n\n[1] \"Les chaînes de caractère peuvent être concaténées.\"\n\n\n\n🔍Pour aller plus loin 🔍 le package stringr permet de traiter les chaînes de caractère : mettre en majuscules, mettre en minuscules, extraire une sous-chaîne…\n\n\nUn booléen peut valoir TRUE ou FALSE : c’est une variable qui indique si une condition logique est vérifiée.\n\n\n# Test de l'égalité\nprint(1 == 2)\n\n\n\n\n\n[1] FALSE\n\n\n\n\n\n\na &lt;- (\"Dares\" == \"Dares\")\nprint(a)\n\n\n\n\n\n[1] TRUE\n\n\n\n\n\n\n# Comparaison numérique\nprint(2 &lt; 3)\n\n\n\n\n\n[1] TRUE\n\n\n\n\n\n\nprint(4 &gt;= 5)\n\n\n\n\n\n[1] FALSE\n\n\n\n\n\n\nb &lt;- 3 &lt;= 2\nprint(b)\n\n\n\n\n\n[1] FALSE\n\n\n\n\n\n\n# Test de la différence\nprint(\"A\" != \"a\")\n\n\n\n\n\n[1] TRUE\n\n\n\n❗ Attention : R est sensible à la casse ❗",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#les-structures-de-données-de-base-en-r",
    "href": "slides.html#les-structures-de-données-de-base-en-r",
    "title": "Prise en main des données avec R",
    "section": "Les structures de données de base en R",
    "text": "Les structures de données de base en R\n\nVecteursListes\n\n\n\nUn vecteur est une séquence ordonnée d’objets élémentaires de même type. Les vecteurs ont un type (correspondant à celui des objets qu’il contient) donné par la fonction class() et une longueur donnée par la fonction length.\n\nvecteur_num &lt;- c(3, 18, 9)\nlength(vecteur_num)\n\n[1] 3\n\n\n\n\nclass(vecteur_num)\n\n[1] \"numeric\"\n\n\n\n\n\nUne liste est une séquence ordonnée, éventuellement hétérogène, d’objets de types quelconques.\nUne liste est toujours de type list, peu importe ce qui la compose.\n\nliste_divers &lt;- list(\"A\", 7, TRUE)\nlength(liste_divers)\n\n[1] 3\n\n\n\n\nclass(liste_divers)\n\n[1] \"list\"\n\n\n\n\n#Accéder aux éléments d'une liste\nprint(liste_divers[[1]])\n\n[1] \"A\"",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#data-frames",
    "href": "slides.html#data-frames",
    "title": "Prise en main des données avec R",
    "section": "Data frames",
    "text": "Data frames\n\nLe data.frame est un tableau sous forme d’une liste (classe list) de vecteurs qui représentent les colonnes. Les vecteurs doivent être de la même longueur, la longueur de chaque vecteur correspond au nombre de lignes/d’observations du tableau.\nPuisque chaque colonne est un vecteur :\n\nune colonne représente une variable d’un type unique ;\nune colonne a un nom, celui de la variable ;\nchaque colonne doit avoir la même hauteur.\n\nLes dimensions du data.frame sont données par la fonction dim().\n\n#Obtenir les dimensions du tableau de l'enquête emploi en continu\ndim(EEC_2019)\n\n[1] 416298    124",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#opérations-de-base-sur-les-data.frames-r-base-ou-dplyr",
    "href": "slides.html#opérations-de-base-sur-les-data.frames-r-base-ou-dplyr",
    "title": "Prise en main des données avec R",
    "section": "Opérations de base sur les data.frames : R base ou dplyr ?",
    "text": "Opérations de base sur les data.frames : R base ou dplyr ?\n\n👉 But : si vous rencontrez des syntaxes Rbase, les comprendre. Nous recommandons pour débuter d’utiliser plutôt les syntaxes dplyr présentées plus loin.\n❓ Pourquoi ❓\nLa syntaxe de dplyr est à notre avis plus lisible et intuitive pour s’initier à R, et aussi largement utilisée par la communauté des utilisateurs de R, ce qui facilite le partage de solutions.\n\n\n\n\n\n\nNote\n\n\nIl n’existe pas une manière unique de programmer en R, et l’utilisation de Rbase présente aussi des avantages : la stabilité par exemple, la meilleure reproductibilité car nécessite moins de packages et de dépendances… Cette formation propose une manière de programme utilisant plutôt le tidyverse",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#opérations-de-base-sur-les-data.frames-r-base",
    "href": "slides.html#opérations-de-base-sur-les-data.frames-r-base",
    "title": "Prise en main des données avec R",
    "section": "Opérations de base sur les data.frames : R base",
    "text": "Opérations de base sur les data.frames : R base\n\nSélectionner des lignesSélectionner des colonnes\n\n\n\nObtenir le nom des lignes :\n\n\nrownames(EEC_ex)\n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\" \"27\" \"28\" \"29\" \"30\"\n\n\n\n\nSélectionner la 5ème ligne :\n\n\nEEC_ex[5,]\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n5 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n\n\n\n\nSélectionner les lignes 10 et 35 :\n\n\nEEC_ex[c(10,35),]\n\n    SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n10 Homme     1      2   15      4        EV   15  2019      5\nNA  &lt;NA&gt;    NA     NA   NA     NA      &lt;NA&gt;   NA    NA     NA\n\n\n\n\nSélectionner les lignes 3 à 8 :\n\n\nEEC_ex[c(3:8),]\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n3 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n4 Homme     1      1   60      6        EU   50  2019      1\n5 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n6 Homme     1      1   60      6        EU   50  2019      1\n7 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n8 Homme     1      1   40      4        ET   30  2019      5\n\n\n\n\n\nConnaître le nom des colonnes/variables :\n\n\nnames(EEC_ex)\n\n[1] \"SEXE\"      \"ACTIF\"     \"COURED\"    \"AGE5\"      \"CSTOTR\"    \"NAFG004UN\"\n[7] \"AGE3\"      \"ANNEE\"     \"JOURTR\"   \n\n\n\n\nSélectionner une colonne solution 1 : la 3ème colonne :\n\n\nEEC_ex[, 3]\n\n [1] 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1\n\n\n\n\nSélectionner une colonne solution 2, la variable ACTIF :\n\n\nEEC_ex[\"ACTIF\"]\n\n   ACTIF\n1      2\n2      1\n3      2\n4      1\n5      2\n6      1\n7      2\n8      1\n9      1\n10     1\n11     1\n12     1\n13     1\n14     1\n15     1\n16     2\n17     2\n18     2\n19     2\n20     2\n21     2\n22     2\n23     1\n24     2\n25     1\n26     2\n27     2\n28     2\n29     2\n30     2\n\n\n\n\nSélectionner une colonne solution 3, la variable ACTIF\n\n\nEEC_ex$ACTIF\n\n [1] 2 1 2 1 2 1 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 1 2 1 2 2 2 2 2\n\n\n\n\nConnaître le type des variables :\n\n\nclass(EEC_ex$AGE3)\n\n[1] \"integer\"\n\n\n\n\nSélectionner la 3ème ligne et les colonnes SEXE et ACTIF :\n\n\nEEC_ex[3, c(\"SEXE\", \"ACTIF\")]\n\n   SEXE ACTIF\n3 Femme     2",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#opérations-de-base-sur-les-data.frames-convertir-des-colonnes",
    "href": "slides.html#opérations-de-base-sur-les-data.frames-convertir-des-colonnes",
    "title": "Prise en main des données avec R",
    "section": "Opérations de base sur les data.frames : convertir des colonnes",
    "text": "Opérations de base sur les data.frames : convertir des colonnes\n\nConvertir une variable numérique en caractère :\n\nclass(EEC_ex$ANNEE)\n\n[1] \"integer\"\n\nEEC_ex$ANNEE &lt;- as.character(EEC_ex$ANNEE)\nclass(EEC_ex$ANNEE)\n\n[1] \"character\"\n\n\n\nConvertir une colonne caractère en numérique :\n\nEEC_ex$ANNEE &lt;- as.numeric(EEC_ex$ANNEE)\nclass(EEC_ex$ANNEE)\n\n[1] \"numeric\"",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#les-facteurs-un-outil-pour-les-variables-qualitatives",
    "href": "slides.html#les-facteurs-un-outil-pour-les-variables-qualitatives",
    "title": "Prise en main des données avec R",
    "section": "Les facteurs : un outil pour les variables qualitatives",
    "text": "Les facteurs : un outil pour les variables qualitatives\nLe type factor en R permet de manipuler des variables qualitatives.\nLe package forcats permet de traiter les facteurs : recoder les modalités, les ordonner…\n\nConvertirModalitésRecoder\n\n\n\nclass(EEC_2019$SEXE)\n\n[1] \"integer\"\n\n#Conversion de la variable SEXE de numérique en facteur\nEEC_2019$SEXE &lt;- as.factor(EEC_2019$SEXE)\n\nclass(EEC_2019$SEXE)\n\n[1] \"factor\"\n\n\n\n\nLa fonction levels() permet de connaître l’ensemble des modalités existantes d’un facteur (même si elles ne sont plus présentes dans les données après sélection des lignes).\n\nlevels(EEC_2019$SEXE)\n\n[1] \"1\" \"2\"\n\n\n\n\nLa fonction fct_recode() permet de renommer les modalités d’un facteur, avec la syntaxe suivante :\n\nnouvelle_variable &lt;- fct_recode(ancienne_variable,\n                                \"Nouvelle_valeur1\" = \"Ancienne_valeur1\",\n                                \"Nouvelle_valeur2\" = \"Ancienne_valeur2\",\n                                NULL = \"Modalite_a_supprimer\")\n\nExemple : Recodage des modalités de la variable SEXE.\n\nlibrary(forcats)\n\nEEC_2019$SEXE &lt;- fct_recode(EEC_2019$SEXE,\n                            \"Homme\" = \"1\",\n                            \"Femme\" = \"2\")\n\nlevels(EEC_2019$SEXE)\n\n[1] \"Homme\" \"Femme\"",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#opérations-de-base-sur-les-data.frames-les-valeurs-manquantes",
    "href": "slides.html#opérations-de-base-sur-les-data.frames-les-valeurs-manquantes",
    "title": "Prise en main des données avec R",
    "section": "Opérations de base sur les data.frames : les valeurs manquantes",
    "text": "Opérations de base sur les data.frames : les valeurs manquantes\nLorsqu’une valeur est manquante dans une enquête par exemple, elle figure sous forme de la modalité NA, “Not Available”, qui existe pour tous les types de variables.\nSelon la manière dont ces valeurs manquantes existent dans les données à importer dans R, elles ne sont pas forcément détectées comme telles. Par exemple :\n\ntest_na &lt;- as.data.frame(\n  list(\n  c(1, \".\", 3),\n  c(\"A\", \"E\", \".\")\n  )\n  )\n\nnames(test_na) &lt;- c(\"Var1\", \"Var2\")\n\nprint(test_na)\n\n  Var1 Var2\n1    1    A\n2    .    E\n3    3    .\n\n\nIl faut les recoder en NA avec la fonction fct_recode() :\n\ntest_na$Var1 &lt;- as.factor(test_na$Var1)\n\ntest_na$Var1 &lt;- fct_recode(test_na$Var1,\n                           NULL = \".\")\n\nprint(test_na)\n\n  Var1 Var2\n1    1    A\n2 &lt;NA&gt;    E\n3    3    .",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#les-dates-sous-r",
    "href": "slides.html#les-dates-sous-r",
    "title": "Prise en main des données avec R",
    "section": "Les dates sous R",
    "text": "Les dates sous R\nLe format de date le plus courant en R est la classe Date. Elle correspond à une distance par rapport à une date origine, ce qui permet de faire des calculs (distance entre deux dates par exemple).\n\nCréer une dateComposantsIntervalle\n\n\nIl est possible de créer une date à partir d’une chaîne de caratère. Le format standard est “AAAA-MM-JJ”, mais il est possible de spécifier un autre format.\n\ndate_1 &lt;- as.Date(\"2023-01-24\")\n\ndate_2 &lt;- as.Date(\"12/07/2022\", format = \"%d/%m/%Y\")\n\n\n\nLe package lubridate permet de traiter les dates. Il n’est pas présenter davantage ici, voici simplement comment il est possible d’accéder aux composants d’une date avec lubridate :\n\nlibrary(lubridate)\n\nyear(date_1)\n\n[1] 2023\n\nmonth(date_1)\n\n[1] 1\n\nquarter(date_1)\n\n[1] 1\n\nday(date_1)\n\n[1] 24\n\n\n\n\nAvec le type Date, vient la notion d’intervalle temporel, qui est également un type de données à part entière. La fonction interval() permet de calculer des durées.\n\nlibrary(lubridate)\n\ndate_1 &lt;- as.Date(\"2023-01-24\")\n\ndate_2 &lt;- as.Date(\"12/07/2022\", format = \"%d/%m/%Y\")\n\nintervalle &lt;- interval(date_1, date_2)\nintervalle\n\n[1] 2023-01-24 UTC--2022-07-12 UTC\n\nclass(intervalle)\n\n[1] \"Interval\"\nattr(,\"package\")\n[1] \"lubridate\"",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#tidyverse-dplyr-et-le-pipe",
    "href": "slides.html#tidyverse-dplyr-et-le-pipe",
    "title": "Prise en main des données avec R",
    "section": "Tidyverse, dplyr et le pipe",
    "text": "Tidyverse, dplyr et le pipe\n\nLa majorité des utilisateurs de R utilisent un ensemble de package contenu dans le tidyverse , qui propose des fonctions alternatives à Rbase. Nous vous recommandons d’utiliser le tidyverse, et en particulier le package dplyr, pour rédiger vos programmes.\nAvantages du tidyverse et de dplyr :\n\nplus lisible, plus proche d’un langage interprété que R base ;\nutilisé par la majorité des utilisateurs de R ;\nstable.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#le-pipe",
    "href": "slides.html#le-pipe",
    "title": "Prise en main des données avec R",
    "section": "Le pipe",
    "text": "Le pipe\n\nPour enchaîner différentes instructions sur un data.frame, on utilise le “pipe” : %&gt;%, un opérateur qui permet de prendre ce qu’il y a à gauche du pipe pour l’injecter en entrée (argument) dans la fonction à droite du pipe.\nAttention : il est recommandé de définir un nouveau tableau pour enregistrer les opérations sur un data.frame.\nLes bonnes pratiques de rédaction d’un code sont renseignées dans UtilitR - Les bonnes pratiques",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#sélectionner-des-colonnes-1",
    "href": "slides.html#sélectionner-des-colonnes-1",
    "title": "Prise en main des données avec R",
    "section": "Sélectionner des colonnes",
    "text": "Sélectionner des colonnes\n\nSélectionner des colonnes par leur nom avec select() :\n\n#Les colonnes année et Age3\nnouveau_df_1 &lt;- EEC_ex %&gt;%\n  select(ANNEE, AGE3)\n\nhead(nouveau_df_1, 5)\n\n  ANNEE AGE3\n1  2019   50\n2  2019   50\n3  2019   50\n4  2019   50\n5  2019   50\n\n\n\n\nSupprimer une colonne avec le - dans select() :\n\n#Toutes les colonnes sauf Age3\nnouveau_df_2 &lt;- EEC_ex %&gt;%\n  select(-AGE3)\n\nhead(nouveau_df_2, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN ANNEE JOURTR\n1 Femme     2      2   60      8      &lt;NA&gt;  2019     NA\n2 Homme     1      1   60      6        EU  2019      1\n3 Femme     2      1   60      7      &lt;NA&gt;  2019     NA\n4 Homme     1      1   60      6        EU  2019      1\n5 Femme     2      1   60      7      &lt;NA&gt;  2019     NA",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#afficher-les-premières-lignes",
    "href": "slides.html#afficher-les-premières-lignes",
    "title": "Prise en main des données avec R",
    "section": "Afficher les premières lignes",
    "text": "Afficher les premières lignes\n\nAvant de débuter une analyse, il est utile de visualiser les premières lignes du tableau de données. C’est notamment très utile lorsque les données sont volumineuses et que l’affichage du tableau complet prend du temps.\n\nEEC_debut &lt;- EEC_ex %&gt;%\n  head(5)\nEEC_debut\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Femme     2      2   60      8      &lt;NA&gt;   50  2019     NA\n2 Homme     1      1   60      6        EU   50  2019      1\n3 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n4 Homme     1      1   60      6        EU   50  2019      1\n5 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#filtrer-des-lignes",
    "href": "slides.html#filtrer-des-lignes",
    "title": "Prise en main des données avec R",
    "section": "Filtrer des lignes",
    "text": "Filtrer des lignes\n\nPour filter des lignes selon une ou plusieurs conditions, on utilise la fonction filter() :\n\nEgalitéInégalitéDifférencePlusieurs conditions\n\n\n\nEEC_femme &lt;- EEC_ex %&gt;%\n  filter(SEXE == \"Femme\")\n\nhead(EEC_femme, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Femme     2      2   60      8      &lt;NA&gt;   50  2019     NA\n2 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n3 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n4 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n5 Femme     1      1   40      4        EV   30  2019      5\n\n\n\n\n\nEEC_moins_30 &lt;- EEC_ex %&gt;%\n  filter(AGE5 &lt;= 30)\n\nhead(EEC_moins_30, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Homme     1      2   15      4        EV   15  2019      5\n2 Femme     1      2   15      3        EV   15  2019      5\n3 Homme     1      2   15      4        EV   15  2019      5\n4 Femme     1      2   15      3        EV   15  2019      5\n5 Homme     1      2   15      4        EV   15  2019      5\n\n\n\n\n\nEEC_hors_cadres &lt;- EEC_ex %&gt;%\n  filter(CSTOTR != 3)\n\nhead(EEC_hors_cadres, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Femme     2      2   60      8      &lt;NA&gt;   50  2019     NA\n2 Homme     1      1   60      6        EU   50  2019      1\n3 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n4 Homme     1      1   60      6        EU   50  2019      1\n5 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n\n\n\n\n\n#Opérateur ET\nEEC_femme_moins_30 &lt;- EEC_ex %&gt;%\n  filter(SEXE == \"femme\" & AGE5 &lt;= 30)\n\nhead(EEC_femme_moins_30, 5)\n\n[1] SEXE      ACTIF     COURED    AGE5      CSTOTR    NAFG004UN AGE3     \n[8] ANNEE     JOURTR   \n&lt;0 rows&gt; (or 0-length row.names)\n\n#Opérateur OU\nEEC_femme_ou_cadre &lt;- EEC_ex %&gt;%\n  filter(SEXE == \"femme\" | CSTOTR == 3)\n\nhead(EEC_femme_ou_cadre, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Femme     1      2   15      3        EV   15  2019      5\n2 Femme     1      2   15      3        EV   15  2019      5\n3 Femme     1      2   15      3        EV   15  2019      5\n4 Homme     1      1   50      3        EV   50  2019      5\n5 Homme     1      1   50      3        EV   50  2019      5",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#filtrer-des-lignes-1",
    "href": "slides.html#filtrer-des-lignes-1",
    "title": "Prise en main des données avec R",
    "section": "Filtrer des lignes",
    "text": "Filtrer des lignes\n\n\nInclusion dans une listeValeurs manquantesValeurs distinctes\n\n\n\nEEC_hors_agr &lt;- EEC_ex %&gt;%\n  filter(NAFG004UN %in% c(\"ET\", \"EU\", \"EV\"))\n\nhead(EEC_hors_agr, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Homme     1      1   60      6        EU   50  2019      1\n2 Homme     1      1   60      6        EU   50  2019      1\n3 Homme     1      1   60      6        EU   50  2019      1\n4 Homme     1      1   40      4        ET   30  2019      5\n5 Femme     1      1   40      4        EV   30  2019      5\n\n\n\n\nPour tester si une valeur est manquante, il faut utiliser la fonction is.na(). Le test variable == NA renvoie une erreur.\nPour tester qu’une valeur est bien présente, c’est la condition !(is.na(variable)). la syntaxe !() signifie “différent de”, c’est-à-dire teste la condition contraire à ce qui est renseigné dans les parenthèses.\nUniquement les lignes pour lesquelles NAFG004UN est manquante :\n\nEEC_CSP_na &lt;- EEC_ex %&gt;%\n  filter(is.na(NAFG004UN))\n\nhead(EEC_CSP_na, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Femme     2      2   60      8      &lt;NA&gt;   50  2019     NA\n2 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n3 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n4 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA\n5 Homme     2      2   60      7      &lt;NA&gt;   50  2019     NA\n\n\n\nUniquement les lignes pour lesquelles NAFG004UN est renseignée :\n\nEEC_CSP_hors_na &lt;- EEC_ex %&gt;%\n  filter(!(is.na(NAFG004UN)))\n\nhead(EEC_CSP_hors_na, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR\n1 Homme     1      1   60      6        EU   50  2019      1\n2 Homme     1      1   60      6        EU   50  2019      1\n3 Homme     1      1   60      6        EU   50  2019      1\n4 Homme     1      1   40      4        ET   30  2019      5\n5 Femme     1      1   40      4        EV   30  2019      5\n\n\n\n\nLa fonction distinct() permet de ne sélectionner qu’une seule occurence de chaque combinaison des variables signalées.\nOn ne souhaite qu’une seule occurence de chaque combinaison existant dans les données des variables ANNEE et TRIM :\n\nEEC_periode &lt;- EEC_2019 %&gt;%\n  distinct(ANNEE, TRIM)\n\nhead(EEC_periode, 5)\n\n  ANNEE TRIM\n1  2019    1\n2  2019    2\n3  2019    3\n4  2019    4",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#créer-une-variable",
    "href": "slides.html#créer-une-variable",
    "title": "Prise en main des données avec R",
    "section": "Créer une variable",
    "text": "Créer une variable\n\nAvec if_elseAvec case_whenAvec une condition\n\n\nif_else est utilisé pour renseigner une valeur si une condition est vérifiée, une autre sinon. La syntaxe est la suivante :\n\nmutate(nouvelle_variable = if_else(condition, valeur_condition_verifiee, valeur_sinon))\n\n\nEEC_agr &lt;- EEC_2019 %&gt;%\n  mutate(agriculture = if_else(NAFG004UN == \"ES\", 1, 0))\n\nhead(EEC_agr, 5)\n\n  ANNEE TRIM CATAU2010R METRODOM TYPMEN7 AGE3 AGE5 COURED ENFRED NFRRED  SEXE\n1  2019    1          1        1       1   50   60      2      2      1 Femme\n2  2019    2          1        1       3   50   60      1      2      1 Homme\n3  2019    2          1        1       3   50   60      1      2      1 Femme\n4  2019    3          1        1       3   50   60      1      2      1 Homme\n5  2019    3          1        1       3   50   60      1      2      1 Femme\n  ACTEU ACTEU6 ACTIF ACTOP AIDFAM ANCCHOM ANCINACT CONTACT CREACCP DEM DISPOC\n1     3      6     2     2     NA      NA       NA      NA      NA   0     NA\n2     1      1     1     1     NA      NA       NA      NA      NA   0     NA\n3     3      6     2     2      2      NA        8      NA      NA   0     NA\n4     1      1     1     1     NA      NA       NA      NA      NA   0     NA\n5     3      6     2     2      2      NA        8      NA      NA   0     NA\n  GARDEB HALOR INSCONT MRA MRB MRBBIS MRC MRD MRDBIS MRE MREC MRF MRG MRGBIS\n1     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n2     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n3     NA     2      NA  NA  NA     NA  NA  NA     NA  NA    2  NA  NA     NA\n4     NA     2      NA  NA  NA     NA  NA  NA     NA  NA   NA  NA  NA     NA\n5     NA     2      NA  NA  NA     NA  NA  NA     NA  NA    2  NA  NA     NA\n  MRH MRI MRJ MRK MRL MRM MRN MRO MRPASSA MRPASSB MRPASSC MRS NONDIC NREC NRECA\n1  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n2  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n3  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n4  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n5  NA  NA  NA  NA  NA  NA  NA  NA      NA      NA      NA  NA     NA   NA    NA\n  NRECB OCCREF OFFICC OFFRE PASTRA PASTRB PASTRF PERCREV RABS RAISNREC RAISNSOU\n1    NA      1     NA    NA     NA     NA     NA      NA   NA       NA       NA\n2    NA      2     NA    NA     NA     NA     NA      NA   NA       NA       NA\n3    NA      1     NA    NA      2      2      2      NA   NA       NA        5\n4    NA      2     NA    NA      1     NA      1       1    8       NA       NA\n5    NA      1     NA    NA      2      2      2      NA   NA       NA        5\n  RAISPAS SOU SOUA SOUB SOUC SOUSEMPL STCHE TEMP TRAREF TYPCONT TYPCONTB CHPUB\n1      NA  NA   NA   NA   NA       NA    NA    2     NA      NA       NA    NA\n2      NA   2    2    2   NA       NA    NA   NA      1      NA       NA     1\n3      NA   2   NA   NA    2       NA    NA   NA      2      NA       NA    NA\n4      NA   2    2    2   NA        3    NA   NA      2      NA       NA     1\n5      NA   2   NA   NA    2       NA    NA   NA      2      NA       NA    NA\n  CSE CSER CSP CSTOT CSTOTR FONCTC NAFG004UN NAFG010UN NAFG017UN NAFG021UN\n1  NA   NA  NA    86      8     NA                                        \n2  64    6  64    64      6     NA        EU        FZ        FZ         F\n3  NA   NA  NA    77      7     NA                                        \n4  64    6  64    64      6     NA        EU        FZ        FZ         F\n5  NA   NA  NA    77      7     NA                                        \n  NAFG038UN NAFG088UN PUB3FP QPRC STC RDET STAT2 STATOEP STATUT STATUTR TITC\n1                  NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n2        FZ        43      4    9   3   NA     2      35     35       5   NA\n3                  NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n4        FZ        43      4    9   3   NA     2      35     35       5   NA\n5                  NA     NA   NA  NA   NA    NA      NA     NA      NA   NA\n  CSTMN CSTPLC DISPPLC DUHAB GARDEA HHC6 HORAIC RAISON RAISTP STMN STPLC TPPRED\n1    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n2    NA     NA      NA     1     NA    1      3     NA      5    2     2      2\n3    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n4    NA     NA      NA     1     NA    1      3     NA      5    2     2      2\n5    NA     NA      NA    NA     NA   NA     NA     NA     NA   NA    NA     NA\n  TXTPPRED ANCENTR4 SITANT AAC CSA NAFANT NAFANTG004N DIP11 CSTOTPRM IDENTM\n1       NA       NA     NA   2   0      0          00    70       86      1\n2        1        4      5  NA  NA     NA                50       64      2\n3       NA       NA     NA   1  54     43          EU    70       64      2\n4        1        4      5  NA  NA     NA                50       64      3\n5       NA       NA     NA   1  54     43          EU    70       64      3\n    EXTRIAN EMPNBH HREC HHCE HPLUSA JOURTR NBTOTE agriculture\n1 107.74972     NA   NA   NA     NA     NA     NA           0\n2  46.17385      1   NA    1     NA      1     NA           0\n3  46.17385     NA   NA   NA     NA     NA     NA           0\n4  44.32930      0   NA    1     NA      1     NA           0\n5  44.32930     NA   NA   NA     NA     NA     NA           0\n\n\n\n\ncase_when permet de créer une variable qui prend différentes modalités selon plusieurs conditions évaluées successivement, selon la syntaxe suivante :\n\nmutate(nouvelle_variable = case_when(condition1 ~ valeur1,\n                                     condition2 ~ valeur2,\n                                     condition3 ~ valeur3,\n                                     TRUE ~ valeur_par_défaut))\n\nLes conditions sont explorées successivement jusqu’à ce qu’une d’entre elles donne TRUE, elles ne sont donc pas nécessairement exclusives l’une de l’autre. La dernière ligne « voiture balai » (qui n’est pas obligatoire) exploite cette fonctionnalité avec une condition toujours vraie qui piège tous les cas non explorés.\n\n\nll est également possible de créer directement une variable de type booléen en mentionnat uniquement la condition :\n\nmutate(individu_cadre = (CSTOTR == 3))\n\nLa nouvelle variable individu_cadre vaut TRUE lorsque CSTOTR vaut 3, FALSE sinon.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#modifier-des-variables",
    "href": "slides.html#modifier-des-variables",
    "title": "Prise en main des données avec R",
    "section": "Modifier des variables",
    "text": "Modifier des variables\n\n\nRenommer une variableDiscrétiser une variable quanti\n\n\n\nrename(nouveau_nom_var1 = ancien_nom_var1,\n       nouveau_nom_var2 = ancien_nom_var2)\n\n\nEEC_2 &lt;- EEC_ex %&gt;%\n  rename(AGE_3_classes = AGE3)\n\nhead(EEC_2, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE_3_classes ANNEE JOURTR\n1 Femme     2      2   60      8      &lt;NA&gt;            50  2019     NA\n2 Homme     1      1   60      6        EU            50  2019      1\n3 Femme     2      1   60      7      &lt;NA&gt;            50  2019     NA\n4 Homme     1      1   60      6        EU            50  2019      1\n5 Femme     2      1   60      7      &lt;NA&gt;            50  2019     NA\n\n\n\n\nAvec cut(), la borne inférieure est exclue, la borne supérieure est incluse.\n\nEEC_3 &lt;- EEC_ex %&gt;%\n  mutate(JOURTR_classe = cut(JOURTR, breaks = c(2,4)))\n\nhead(EEC_3, 5)\n\n   SEXE ACTIF COURED AGE5 CSTOTR NAFG004UN AGE3 ANNEE JOURTR JOURTR_classe\n1 Femme     2      2   60      8      &lt;NA&gt;   50  2019     NA          &lt;NA&gt;\n2 Homme     1      1   60      6        EU   50  2019      1          &lt;NA&gt;\n3 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA          &lt;NA&gt;\n4 Homme     1      1   60      6        EU   50  2019      1          &lt;NA&gt;\n5 Femme     2      1   60      7      &lt;NA&gt;   50  2019     NA          &lt;NA&gt;",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#convertir-des-variables",
    "href": "slides.html#convertir-des-variables",
    "title": "Prise en main des données avec R",
    "section": "Convertir des variables",
    "text": "Convertir des variables\nLes fonctions de conversion peuvent être appliquées aux colonnes d’un data.frame. Il est conseillé d’affecter à chaque variable le type le plus proche de sa nature :\n\n#Conversion de la variable ENFRED en facteur et de la variable COURED en caractères :\n\nEEC_2019 &lt;- EEC_2019 %&gt;%\n  mutate(ENFRED = as.factor(ENFRED),\n         COURED = as.character(COURED))\n\n\n\n\n🤔 Comment recoder ? 🤔\n\ntransformer les variables qualitatives en facteurs ;\nordonner les modalités pour les variables qualitatives ordinales ;\nconvertir les variables numériques en numérique ;\nrecoder les valeurs manquantes (par exemple les caractères vides) ;\ntransformer les chaînes de caractère en Date si nécessaire.\n\n\n❓ Pourquoi recoder ❓\n\npour réaliser des statistiques descriptives plus rapidement, par exemple avec la fonction summary ;\npour que les fonctions économétriques détectent une modalité de référence pertinente pour les variables ordinales ;\npour tracer des séries temporelles dans le cas des dates…",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#la-fonction-count",
    "href": "slides.html#la-fonction-count",
    "title": "Prise en main des données avec R",
    "section": "La fonction COUNT",
    "text": "La fonction COUNT\n\n\nConnaitre le nombre de lignes d’un dataframe\n\nOn peut également avoir cette information dans le panneau “environnement”\n\nCompter le nombre d’individus dans une table exhaustive\n\n⛔ Ne pas utiliser pour des données échantillonées ⛔\n\n\n\nNe pas calculer par exemple le nombre de chômeurs au sens du BIT sans pondération à partir de l’EEC :\n\nchomeurs &lt;- EEC_2019 %&gt;% \n  filter(ACTEU == \"2\") %&gt;% \n  count()\n\nprint(paste0(\"Le nombre de chômeurs au sens du BIT N'EST PAS \", as.character(chomeurs)))\n\n[1] \"Le nombre de chômeurs au sens du BIT N'EST PAS 18602\"",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#la-fonction-summarise",
    "href": "slides.html#la-fonction-summarise",
    "title": "Prise en main des données avec R",
    "section": "La fonction summarise",
    "text": "La fonction summarise\n\nCette fonction permet d’avoir un ensemble de statistiques descriptives : effectif, somme, moyenne, médiane, quantile, min, max…\nElle est fréquemment utilisée avec l’instruction group_by(), qui permet d’effectuer ces calculs au sein des groupes formés par les modalités d’une variable.\n\n\n\n\n\n\n\nGroup_by\n\n\nPour les habitués de SQL, group_by n’est pas un mot clé mais une vraie fonction R avec une entrée et une sortie. Le résultat est une table avec les mêmes données mais un « index » en plus disant où sont les observations de chaque modalité. La présence de cet index change le fonctionnement de plusieurs fonctions de dplyr en les forçant à travailler par morceau.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#la-fonction-summarise-1",
    "href": "slides.html#la-fonction-summarise-1",
    "title": "Prise en main des données avec R",
    "section": "La fonction summarise",
    "text": "La fonction summarise\n\n\nEffectifSomme, moyenneDistributionPlusieurs variables\n\n\nLa fonction n() permet d’obtenir les effectifs.\nCalcul du nombre de personnes de 30 ans ou moins :\n\neff_moins_30 &lt;- EEC_2019 %&gt;%\n  filter(AGE3 &lt;= 30) %&gt;%\n  summarise(eff_moins_30 = n())\neff_moins_30\n\n  eff_moins_30\n1       195851\n\n\nCalcul du nombre de personnes par classe d’âge en 3 classes :\n\neff_age_classe &lt;- EEC_2019 %&gt;%\n  group_by(AGE3) %&gt;%\n  summarise(eff_age3 = n())\neff_age_classe\n\n# A tibble: 3 × 2\n   AGE3 eff_age3\n  &lt;int&gt;    &lt;int&gt;\n1    15    78826\n2    30   117025\n3    50   220447\n\n\nCalcul du nombre de personnes par SEXE :\n\neff_sexe &lt;- EEC_2019 %&gt;%\n  group_by(SEXE) %&gt;%\n  summarise(eff_sexe = n())\neff_sexe\n\n# A tibble: 2 × 2\n  SEXE  eff_sexe\n  &lt;fct&gt;    &lt;int&gt;\n1 Homme   196098\n2 Femme   220200\n\n\n\n\nLes fonctions sum() et mean() peuvent être utilisées également avec summarise().\n\n\n\n\n\n\nWarning\n\n\nTout calcul impliquant un NA restitue un NA : les opérations, les tests, les tris. Dans les calculs statistiques (par exemple avec les fonctions appelées par le summarise de dplyr utilisé pour faire des récapitulations : comptages, totaux ou autres statistiques), il y a généralement un argument supplémentaire na.rm (pour “remove”) qui permet de ne pas tenir compte des valeurs manquantes, mais son positionnement par défaut est souvent à “faux” (FALSE, ne pas enlever les valeurs manquantes du calcul).\n\n\n\n⚠️ ATTENTION ⚠️ Les valeurs manquantes sont le principal point d’incompatibilité avec SAS et leur traitement nécessite de redoubler d’attention quand on convertit un programme car le fonctionnement est radicalement différent en R.\nCalcul de la moyenne du nombre de jours travaillés par semaine par sexe :\n\nEEC_jourtr_sexe &lt;- EEC_2019 %&gt;%\n  group_by(SEXE) %&gt;%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))\nEEC_jourtr_sexe\n\n# A tibble: 2 × 2\n  SEXE  moy_jour_tr\n  &lt;fct&gt;       &lt;dbl&gt;\n1 Homme        5.01\n2 Femme        4.74\n\n\n\n\nsummarise() est également utile pour des statistiques de distribution.\nCalcul de statistiques de distribution du nombre de jours travaillés par semaine par classe d’âge :\n\nEEC_jourtr_age &lt;- EEC_2019 %&gt;%\n  group_by(AGE3) %&gt;%\n  summarise(min_jour_tr = min(JOURTR, na.rm = TRUE),\n            q1_jour_tr = quantile(JOURTR, na.rm = TRUE, probs = 0.25),\n            med_jour_tr = median(JOURTR, na.rm = TRUE),\n            q3_jour_tr = quantile(JOURTR, na.rm = TRUE, probs = 0.75),\n            max_jour_tr = max(JOURTR, na.rm = TRUE))\nEEC_jourtr_age\n\n# A tibble: 3 × 6\n   AGE3 min_jour_tr q1_jour_tr med_jour_tr q3_jour_tr max_jour_tr\n  &lt;int&gt;       &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1    15         0.5          5           5          5           7\n2    30         0.5          5           5          5           7\n3    50         0.5          5           5          5           7\n\n\n\n\nIl est possible de renseigner plusieurs variables dans l’instruction group_by(). Les statistiques demandées dans summarise() sont alors calculées au sein de chaque classe formée par le croisement des modalités des deux variables.\n⚠️ ATTENTION ⚠️ la valeur par défaut de l’argument drop_last de la fonction summarise() est TRUE, ce qui implique que le dernier niveau de regroupement (la dernière variable renseignée dans le group_by()) est supprimé à l’issue de l’application de la fonction summarise(). Un warning le précise dans la console lorsque cette fonction est utilisée avec plusieurs variables de regroupement.\nCalcul de la moyenne de jours travaillés par semaine par groupe de sexe croisé avec l’âge en 3 classes :\n\nEEC_jourtr_sexe_age &lt;- EEC_2019 %&gt;%\n  group_by(SEXE, AGE3) %&gt;%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))\nEEC_jourtr_sexe_age\n\n# A tibble: 6 × 3\n# Groups:   SEXE [2]\n  SEXE   AGE3 moy_jour_tr\n  &lt;fct&gt; &lt;int&gt;       &lt;dbl&gt;\n1 Homme    15        4.94\n2 Homme    30        5.02\n3 Homme    50        5.02\n4 Femme    15        4.71\n5 Femme    30        4.76\n6 Femme    50        4.73",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#regrouper-par-catégorie",
    "href": "slides.html#regrouper-par-catégorie",
    "title": "Prise en main des données avec R",
    "section": "Regrouper par catégorie",
    "text": "Regrouper par catégorie\nL’opérateur pipe %&gt;% permet d’enchaîner les opérations sur une table de données.\nIl faut faire attention à cet enchaînement lorsqu’on utilise l’instruction group_by. Cette instruction peut être utilisée avec d’autres fonctions de dplyr (filter() et mutate() par exemple), mais elle ne se comporte pas de la même manière avec toutes les fonctions. En effet, le dernier niveau de regroupement (la dernière variable renseignée dans le group_by()) est supprimé à l’issue de l’application de la fonction summarise(), tandis que ce n’est pas le cas avec les fonctions mutate() et filter().\nAinsi, il est possible d’utiliser l’instruction ungroup() pour remédier au regroupement des observations dans la suite des opérations sur la table.\n\nex_plusieurs_gpes &lt;- EEC_2019 %&gt;%\n  group_by(SEXE, AGE3) %&gt;%\n  mutate(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  distinct(SEXE, moy_jour_tr, AGE3) %&gt;%\n  group_by(SEXE) %&gt;%\n  filter(moy_jour_tr == min(moy_jour_tr))\n\nex_plusieurs_gpes\n\n# A tibble: 2 × 3\n# Groups:   SEXE [2]\n  SEXE  moy_jour_tr  AGE3\n  &lt;fct&gt;       &lt;dbl&gt; &lt;int&gt;\n1 Homme        4.94    15\n2 Femme        4.71    15",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#trier-ses-données",
    "href": "slides.html#trier-ses-données",
    "title": "Prise en main des données avec R",
    "section": "Trier ses données",
    "text": "Trier ses données\nLorsqu’on utilise un regroupement, le résultat est trié en majeur selon ce regroupement. Si on souhaite effectuer un autre tri, il faut déclencher le tri avec la fonction arrange(). Le mot clé desc (malgré la syntaxe, ce n’est pas une fonction) permet de trier par ordre décroissant. Il est possible d’utiliser plusieurs colonnes pour le tri.\n👁️‍🗨️ REMARQUE 👁️‍🗨️ Contrairement à SAS où trier est la procédure la plus utilisée, R se charge de lui même de faire les tris dont il pourrait avoir besoin. Trier n’a généralement un sens que pour organiser la présentation de résultats.\n\nex_arrange &lt;- EEC_2019 %&gt;%\n  select(SEXE, AGE3, JOURTR) %&gt;%\n  group_by(SEXE, AGE3) %&gt;%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %&gt;%\n  arrange(moy_jour_tr)\nex_arrange\n\n# A tibble: 6 × 3\n# Groups:   SEXE [2]\n  SEXE   AGE3 moy_jour_tr\n  &lt;fct&gt; &lt;int&gt;       &lt;dbl&gt;\n1 Femme    15        4.71\n2 Femme    50        4.73\n3 Femme    30        4.76\n4 Homme    15        4.94\n5 Homme    50        5.02\n6 Homme    30        5.02\n\n\nREMARQUE : Contrairement à SAS où trier est la procédure la plus utilisée, R se charge de lui même de faire les tris dont il pourrait avoir besoin. Trier n’a généralement un sens que pour organiser la présentation de résultats.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#connaitre-le-numéro-de-ligne",
    "href": "slides.html#connaitre-le-numéro-de-ligne",
    "title": "Prise en main des données avec R",
    "section": "Connaitre le numéro de ligne",
    "text": "Connaitre le numéro de ligne\nLa fonction row_number() permet de connaître l’ordre de classement de l’observation dans la table.\nLes fonctions first() et last() permettent de récupérer respectivement la première et la dernière observation d’un groupe.\n\nex_arrange_2 &lt;- EEC_2019 %&gt;%\n  select(SEXE, AGE3, JOURTR) %&gt;%\n  group_by(SEXE, AGE3) %&gt;%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %&gt;%\n  arrange(moy_jour_tr) %&gt;%\n  mutate(numero = row_number())\nex_arrange_2\n\n# A tibble: 6 × 4\n# Groups:   SEXE [2]\n  SEXE   AGE3 moy_jour_tr numero\n  &lt;fct&gt; &lt;int&gt;       &lt;dbl&gt;  &lt;int&gt;\n1 Femme    15        4.71      1\n2 Femme    50        4.73      2\n3 Femme    30        4.76      3\n4 Homme    15        4.94      1\n5 Homme    50        5.02      2\n6 Homme    30        5.02      3",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#travailler-avec-des-données-pondérées",
    "href": "slides.html#travailler-avec-des-données-pondérées",
    "title": "Prise en main des données avec R",
    "section": "Travailler avec des données pondérées",
    "text": "Travailler avec des données pondérées\nLe package Hmisc permet de traiter des données pondérées.\nDes fonctions utilisant des pondérations se trouvent dans le package Hmisc, elles utilisent un argument supplémentaire weights qui permet de passer la colonne contenant les pondérations. Il s’agit de :\n\nwtd.mean : la moyenne\nwtd.var : la variance (en déduire l’écart type si besoin)\nwtd.quantile : un quantile, plusieurs algorithmes sont implémentés, mais aucun ne correspond à ce que fait SAS.\n\n\ndf &lt;- data.frame(age = c(20, 30, 40, 50, 60), poids=c(1, 1, 1, 1, 3))\n\nlibrary(Hmisc)\n\nnew_df &lt;- df %&gt;% \n  summarise(quartile1 = wtd.quantile(age,w=poids,probs=.25),\n            mediane = wtd.quantile(age,w=poids,probs=.5),\n            moyenne = wtd.mean(age,w=poids))",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#concaténations",
    "href": "slides.html#concaténations",
    "title": "Prise en main des données avec R",
    "section": "Concaténations",
    "text": "Concaténations\n\nDes lignesDes colonnes\n\n\n\nMettre les lignes d’une table derrière les lignes d’une autre : la fonction bind_rows()\n\nLes deux listes de colonnes peuvent ne pas être strictement identiques : les données ne sont mises bout à bout que si les noms des colonnes coïncident, sinon des valeurs manquantes sont générées.\nLes colonnes peuvent être dans un ordre différent dans les deux tables, la fonction se charge de les réordonner.\nPar contre une colonne de même nom doit avoir le même type dans les deux tables ou la concaténation ne se fait pas.\n\n\n\n\nMettre les colonnes d’une table à coté des colonnes d’une autre : la fonction bind_cols().\n\nLe nombre de lignes doit coïncider dans les deux tables : c’est un garde-fou contre les erreurs de manipulation, car la fonction ne réalise pas une jointure mais une simple juxtaposition.\nL’usage de cette fonction est donc plus rare et limité aux situations où on est absolument sûr d’avoir le bon nombre de lignes et des données qui sont rangées de la même façon dans les deux tables.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#jointures",
    "href": "slides.html#jointures",
    "title": "Prise en main des données avec R",
    "section": "Jointures",
    "text": "Jointures\n\nA gauche/à droiteInterneExterneAnti_join\n\n\n\n\n\n\ntable_jointe &lt;- table_1 %&gt;%\n  left_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                            \"var3_table1\" = \"var4_table2\"))\n\n\n\n\n\n\n\n\n\n\n\ntable_jointe &lt;- table_1 %&gt;%\n  inner_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                             \"var3_table1\" = \"var4_table2\"))\n\n\n\n\n\n\n\n\n\n\n\ntable_jointe &lt;- table_1 %&gt;%\n  full_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                            \"var3_table1\" = \"var4_table2\"))\n\n\n\n\n\n\n\n\nPour récupérer les observations de la table de gauche qui sont absentes de la table de droite.\n\n\n\ntable_jointe &lt;- table_1 %&gt;%\n  anti_join(table_2, by = c(\"var1_table1\" = \"var2_table2\",\n                            \"var3_table1\" = \"var4_table2\"))",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#transpositions",
    "href": "slides.html#transpositions",
    "title": "Prise en main des données avec R",
    "section": "Transpositions",
    "text": "Transpositions\n\nPour pivoter des données, il est possible d’utiliser les fonctions pivot_longer() et pivot_wider() du package tidyr.\nPar exemple, pour la fonction pivot_longer(), la syntaxe est la suivante : pivot_longer(cols = c(\"Var_1_pivotee\", \"Var_2_pivotee\"), names_to = c(\"nom_de_la_nouvelle_colonne\"))\n\nlibrary(tidyr)\n\nex_pivot &lt;- EEC_2019 %&gt;%\n  select(SEXE, AGE3, JOURTR) %&gt;%\n  group_by(SEXE, AGE3) %&gt;%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE),\n            med_jour_tr = median(JOURTR, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  pivot_longer(cols = c(\"moy_jour_tr\", \"med_jour_tr\"), names_to = c(\"indicateur\"))\nex_pivot\n\n# A tibble: 12 × 4\n   SEXE   AGE3 indicateur  value\n   &lt;fct&gt; &lt;int&gt; &lt;chr&gt;       &lt;dbl&gt;\n 1 Homme    15 moy_jour_tr  4.94\n 2 Homme    15 med_jour_tr  5   \n 3 Homme    30 moy_jour_tr  5.02\n 4 Homme    30 med_jour_tr  5   \n 5 Homme    50 moy_jour_tr  5.02\n 6 Homme    50 med_jour_tr  5   \n 7 Femme    15 moy_jour_tr  4.71\n 8 Femme    15 med_jour_tr  5   \n 9 Femme    30 moy_jour_tr  4.76\n10 Femme    30 med_jour_tr  5   \n11 Femme    50 moy_jour_tr  4.73\n12 Femme    50 med_jour_tr  5   \n\n\nL’article Les pivots expliqués à ma fille est particulièrement bien fait sur le sujet.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#graphiques-avec-plot",
    "href": "slides.html#graphiques-avec-plot",
    "title": "Prise en main des données avec R",
    "section": "Graphiques avec plot",
    "text": "Graphiques avec plot\nVoici une présentation succinte de quelques fonctions usuelles de Rbase permettant de faire des graphiques :\n\nBarplotHistPlot\n\n\n\nex_barplot &lt;- EEC_2019 %&gt;%\n  select(SEXE, JOURTR) %&gt;%\n  group_by(SEXE) %&gt;%\n  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))\n\nbarplot(ex_barplot$moy_jour_tr, legend.text = ex_barplot$SEXE)\n\n\n\n\n\n\n\n\n\n\n\nex_hist &lt;- EEC_2019 %&gt;%\n  select(JOURTR)\n\nhist(ex_hist$JOURTR)\n\n\n\n\n\n\n\n\n\n\n\ndata(iris)\nplot(x = iris$Sepal.Length, y = iris$Sepal.Width)",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "slides.html#ressources-sur-ggplot2",
    "href": "slides.html#ressources-sur-ggplot2",
    "title": "Prise en main des données avec R",
    "section": "Ressources sur ggplot2",
    "text": "Ressources sur ggplot2\n\nLe package ggplot2 permet de créer des graphiques très souplement, en modifiant une grande partie des paramètres. Il ne fait pas l’objet d’une présentation ici, mais pour s’y former, la fiche UtilitR sur le sujet UtilitR-Ggplot2 , ainsi que le site R-graph-gallery vous sont recommandés.\nEnfin, pour avoir des recommandations sur les différents types de visualisation possibles selon la nature des variables à représenter, le site From Data to Viz est très utile.",
    "crumbs": [
      "Slides"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Formation R",
    "section": "",
    "text": "Note\n\n\n\n\nR et R studio sont disponibles sur le centre logiciel ainsi que sur posit.\nLe cahier d’exercice est disponible sur Gitlab.\n\n\n\n\n1 Objectifs ✔️\n\nConnaitre l’environnement R (packages, objets)\nImporter, nettoyer et enrichir ses données\nProduire des statisitiques descriptives\nProduire un code reproductible suivant les règles de bonne conduite\n\n\n\n2 Emploi du temps\n\n\n\nDurée\nProgramme\n\n\n\n\n2 heures\nSlides : Formation théorique jusqu’à la slide 41\n\n\n45 minutes\nExercice 1 : Débuter avec R\n\n\n1 heure\nFin des Slides : Formation théorique\n\n\n45 minutes\nExercice 2 : Nettoyer et enrichir les données\n\n\n45 minutes\nExercice 3 : Statistiques descriptives\n\n\n45 minutes\nExercice 4 : Pour aller plus loin\n\n\n\n\n\n3 Des outils utiles à connaitre 🧰\n\n\n\n\n\n\nLes fonctions help et ? permettent d’avoir des informations sur la fonction que l’on utilise\n\n\n\n\n\nLa fonction help est très pratique pour se renseigner sur une fonction. Elle montre tous les arguments de la fonction et propose des exemples.\n\n# Permet d'avoir les informations sur la fonction mean \nhelp(\"mean\") \n?mean\n\n\n\n\n\n\n\n\n\n\nLes opérateurs R\n\n\n\n\n\n\n\n\n\n\n\n\n\nOpérateur\nSignification\nExemple\n\n\n\n\n+\nSomme\nmutate(variable = variable + 1)\n\n\n/\nDivision\nmutate(variable = variable / 100)\n\n\n*\nMultiplication\nmutate(variable = variable * 100)\n\n\n&\net\nfilter(variable &gt; 10 & variable &lt; 20)\n\n\n|\nou\nfilter(variable_1 == 10 | variable_2 == 20)\n\n\n==\négal\nfilter(variable == 10)\n\n\n!=\ndifférent\nfilter(variable != 10)\n\n\n&lt;\ninférieur\nfilter(variable &lt; 10)\n\n\n&gt;\nsupérieur\nfilter(variable &gt; 10)\n\n\n&lt;=\ninférieur ou égal\nfilter(variable &lt;= 10)\n\n\n&gt;=\nsupérieur ou égal\nfilter(variable &gt;= 10)\n\n\n%in%\nappartenant\nfilter(variable %in% c(10,20,30)\n\n\n\n\n\n\n\n\n\n\n\n\nAvoir des informations sur sa session avec la fonction sessionInfo()\n\n\n\n\n\nCeci permet de connaitre sa version de R, les packages attachés à la session, etc.\n\nsessionInfo() # Permet d'avoir des informations sur la session en cours dont la version de R\ngetRversion() # Permet d'identifier la version de R\nversion() # Permet d'obtenir différentes informations sur R\n\n\n\n\n\n\n\n\n\n\nConnaitre les packages installés sur son environnement avec library()\n\n\n\n\n\n\nlibrary() # Permet de connaitre les packages installés\n\n\n\n\n\n\n\n\n\n\nConnaitre les packages chargés dans son environnement avec search()\n\n\n\n\n\n\nsearch() # Permet de connaitre les packages chargés \n\n\n\n\n\n\n\n\n\n\nConnaitre la version d’un package avec packageVersion()\n\n\n\n\n\n\npackageVersion(\"dplyr\") # Permet de connaitre la version du package dplyr",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "exercice_2.html",
    "href": "exercice_2.html",
    "title": "Exercice 2 : Nettoyer et enrichir les données",
    "section": "",
    "text": "Précédemment, nous avons vu comment se renseigner sur un objet (type, nom des colonnes, nombre d’observations) et comment enchaîner les pipes pour sélectionner, filtrer et enrichir ses données.\n\n1 Créer un projet RStudio\n\nCréer un nouveau projet RStudio.\nCréer un script R et l’enregistrer dans le dossier du projet.\nCopier les données de l’Enquête Emploi 2019 dans le dossier du projet RStudio, c’est-à-dire dans le même dossier que le fichier .Rproj.\nCharger le package dplyr.\n\n\nCode\n#install.packages(\"dplyr\") # Installation du package si besoin\nlibrary(\"dplyr\") # Chargement du package : nécessaire à chaque début de session de travail dans R Studio\n\n\n\n\n\n\n2 Importer les données de l’Enquête emploi 2019\n\nImporter les données .csv de l’Enquête emploi 2019 avec la fonction read.csv2 et lui assigner le nom EEC_2019.\n\n\nCode\nEEC_2019 &lt;- read.csv2(\"FD_EEC_2019.csv\", \n                      header = TRUE, \n                      sep = \";\", \n                      quote = \"\\\"\", \n                      dec = \".\", \n                      fill = TRUE, \n                      comment.char = \"\")\n\n\nObtenir des informations sur le dataframe\n\nNombre de lignes\nNom des colonnes\nModalités de certaines variables\nType des variables\n\n\n\nCode\nnrow(EEC_2019) # Nombre de lignes\ncolnames(EEC_2019) # Nom des colonnes\nstr(EEC_2019) # Informations sur le dataframe et les variables\n\n\n\n\n\n\n3 Mettre en forme ses données\nOn va désormais enchaîner les opérations, il faut donc créer un dataframe et enchaîner les pipes pour obtenir notre dataframe final.\n\nCréer un dataframe en gardant uniquement les variables de la liste suivante : TRIM, ANNEE, AGE5, SEXE, ACTEU, RABS, CSTOTR, HHC6, EXTRIAN, ACTIF, NAFG088UN\n\n\nCode\ndf_final &lt;- EEC_2019 %&gt;% \n  select(TRIM, \n         ANNEE, \n         AGE5, \n         SEXE, \n         ACTEU, \n         RABS, \n         CSTOTR, \n         HHC6, \n         EXTRIAN, \n         ACTIF, \n         NAFG088UN) # Garder uniquement les variables contenues dans liste_variable \n\n\nDans le nouveau dataframe, créer une variable trimestre concaténant la variable TRIM et ANNEE à l’aide de la fonction paste0(). Nous souhaitons obtenir une variable sous la forme “2019-T4”.\n\n\nCode\n... %&gt;% mutate(trimestre = paste0(ANNEE,\"-T\",TRIM))\n\n\nAfficher les modalités de la variable RABS.\n\n\nCode\nunique(EEC_2019$RABS)\n\n\nRemplacer les NA de la variable RABS par des 0 avec la fonction replace().\n\n\nCode\n... %&gt;% mutate(RABS = replace(RABS, is.na(RABS), 0))\n\n# Autre solution avec ifelse\n... %&gt;% mutate(RABS = ifelse(is.na(RABS) == TRUE, 0, RABS))\n\n\nRemplacer les NA de toutes les variables par des 0 avec la fonction mutate_all().\n\n\nCode\n... %&gt;% mutate_all( ~ replace(., is.na(.) == TRUE, 0)) # Mutate all permet de modifier toutes les variables \n\n\nLes données de l’enquête emploi sont des données pondérées, renommer la variable EXTRIAN par POIDS.\n\n\nCode\n... %&gt;% rename(POIDS = EXTRIAN)\n\n\nTrier les données par trimestre dans l’ordre croissant à l’aide de la fonction arrange().\n\n\nCode\n... %&gt;% arrange(trimestre) # Tri du dataframe en fonction du trimestre\n\n\n\n\n\n\n4 Créer des variables conditionnelles\n\nA l’aide de la fonction if_else(), ajouter une variable chomage prenant la valeur “oui” lorsque la variable ACTEU prend la valeur 2, “non” sinon.\n\n\nCode\n... %&gt;% mutate(chomage = if_else(ACTEU == \"2\", \"oui\", \"non\"))\n\n\nA l’aide de la fonction case_when(), créer une variable statut_activite_libelle prenant les modalités ci-dessous :\n\n\nCode\n... %&gt;% mutate(statut_activite_libelle = case_when(ACTEU == \"0\" ~  \"Sans objet\",\n                                      ACTEU == \"1\" ~  \"Actif occupé\",\n                                      ACTEU == \"2\" ~  \"Chômeur\",\n                                      ACTEU == \"3\" ~  \"Inactif\",\n                                      TRUE ~ \"Oubli\"))\n\n\n\n\n\n\nModalité\nDéfintion\n\n\n\n\n“0”\nSans objet\n\n\n“1”\nActif occupé\n\n\n“2”\nChômeur\n\n\n“3”\nInactif\n\n\n\n\n\n\n\n\n\nBonne pratique\n\n\n\nLors de la création d’une variable conditionnelle avec la fonction case_when(), il est conseillé de systématiquement définir une valeur par défaut avec une dernière condition fixée à TRUE, qui permettra de repérer les cas “oubliés”, non concernés par les conditions précédentes.\n\n\n\n\n\n5 Joindre des données\nNous allons désormais récupérer les intitulés de la NAF en 88 postes (variable NAFG088UN) à l’aide des jointures.\n\n\n\n\n\n\nNote\n\n\n\nEn copiant le fichier naf2008_liste_n2.xlsx dans le dossier du projet, on utilise les avantages des chemins relatifs et on peut ne spécifier que le nom du fichier dans l’import, sans le chemin absolu sur le disque.\n\n\n\nImporter le fichier naf2008_liste_n2.xlsx via la fonction read.xlsx() du package openxlsx. Attention, les données à importer commencent à la troisième ligne du document Excel. Trouver l’option de read.xlsx() qui permet de le spécifier\n\n\nCode\n#install.packages(\"openxlsx) # Installation du package si nécessaire\nlibrary(openxlsx)\nintitule_naf &lt;- read.xlsx(\"naf2008_liste_n2.xlsx \",\n                          startRow = 3) \n\n\nCréer un dataframe unique en joignant les libellés NAF via la fonction inner_join(). Pourquoi le nombre d’observations de df_final_inner est inférieur à celui de df_final ?\n\n\nCode\ndf_final_inner &lt;- df_final %&gt;% \n  mutate(NAFG088UN = as.character(NAFG088UN)) %&gt;%\n  inner_join(intitule_naf, by = join_by(\"NAFG088UN\" == \"Code\")) \n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDeux conseils pour réaliser la jointure : Les variables permettant de réaliser la jointure ne portent pas le même nom. Il est toujours utile de regarder les exemples d’utilisation proposés dans l’aide de la fonction ?inner_join. Les variables de jointure ne doivent pas obligatoirement porter le même nom, mais elles doivent être de même type pour que la jointure fonctionne. A vous de jouer pour trouver la solution !\n\n\n\nComment faire pour conserver toutes les observations de df_final en joingnant les libellés NAF ? Créer un nouveau data.frame qui répond à la question.\n\n\nCode\ndf_final_left &lt;- df_final %&gt;% \n  mutate(NAFG088UN = as.character(NAFG088UN)) %&gt;%\n  left_join(intitule_naf, by = join_by(\"NAFG088UN\" == \"Code\"))\n\n\nCréer un dataframe qui correspond à la jointure de df_final et des libellés NAF via la fonction full_join(). Qu’est ce que cette jointure permet de faire ?\n\n\nCode\ndf_final_full &lt;- df_final %&gt;% \n  mutate(NAFG088UN = as.character(NAFG088UN)) %&gt;%\n  full_join(intitule_naf, by = join_by(\"NAFG088UN\" == \"Code\"))\n\n\nLequel de ces data frames joints avec les libellés conservieriez-vous pour une étude avec les données EEC ?\n\n\n\n\n\n\n\nLes principaux types de jointure\n\n\n\n\n\n\ninner_join() : Retourne les observations lorsque l’identifiant est présent dans les deux tables.\n\n\n\nleft_join() : Retourne toutes les observations de la table de gauche, même si l’identifiant n’est pas présent dans la table de droite.\n\n\n\nright_join() : Retourne toutes les observations de la table de droite, même si l’identifiant n’est pas présent dans la table de gauche.\n\n\n\nfulljoin() : Retourne l’ensemble des observations des deux tables, même lorsque l’identifiant ne se retrouve que dans l’une des tables.\n\n\n\n\n\n\n\n\n\n\n\nEmpiler ou coller des données\n\n\n\n\n\nAvec R, nous pouvons aussi empiler des données avec bind_cols() ou bien les coller entre elles avec bind_rows(). Cependant, nous vous conseillons d’utiliser les jointures classiques (inner_join, left_join, …) qui permettent toutes les possibilités avec des identifiants de jointure.\n\nbind_cols() permet d’accoler 2 objets via les colonnes. Il est nécessaire que les variables et l’ordre dans lequel elles apparaissent correspondent.\n\n\n\nbind_rows() permet d’accoler 2 objets via les lignes.\n\n\n\n\n\n\n\n\n6 Enregistrer ses données\nNous avons désormais un dataframe propre et utilisable pour créer des statistiques descriptives : le df_final_left.\n\nSauvegarder dans un dossier son dataframe propre au format .xlsx à l’aide de la fonction write.xlsx(). vérifier que le fichier est bien enregistré à l’endroit renseigné.\n\n\nCode\nwrite.xlsx(df_final_left, file = \"df.xlsx\") # Enregistrement du dataframe\n\n\nCharger son dataframe à l’aide de la fonction read.xlsx() pour vérifier que la sauvegarde est correcte.\n\n\nCode\ndf_charge &lt;- read.xlsx(\"df.xlsx\") # Chargement du dataframe\n\n\nEnregister son fichier et passer à l’exercice 3.",
    "crumbs": [
      "Exercice 2"
    ]
  },
  {
    "objectID": "exercice_4.html",
    "href": "exercice_4.html",
    "title": "Exercice 4 : Pour aller plus loin",
    "section": "",
    "text": "Nous avons vu précédemment comment importer, traiter et résumer ses données.\n\n1 Créer un R projet\nTravailler via un R project est une bonne pratique, cela permet également de faciliter l’accès à des dossiers puisque la racine est définie par l’emplacement du R project.\n\nCréer un R project et l’enregistrer.\nConnaitre où se situe la racine du projet grace à getwd().\n\n\nCode\ngetwd() # Permet de connaitre la racine du working directory\n\n\nInstaller si besoin et charger les packages dplyr, haven, tidyr, lubridate et ggplot2.\n\n\nCode\n# install.packages(haven) \nlibrary(haven) \nlibrary(lubridate)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\n\n\n\n\n\n2 Importer des données SAS sur les demandeurs d’emploi\nLes fichiers SAS sont encore nombreux au sein du SSP, nous allons donc voir comment traiter ces données.\n\nImporter les données SAS du nombre de demandeurs d’emploi via la fonction read_sas() du package haven.\n\n\nCode\ndefm &lt;- read_sas(\"defm_trim.sas7bdat\")\n\n\nChanger le format de la date pour le passer au format Date, attention à l’origine des dates.\n\n\nCode\n... %&gt;% mutate(Date = as.Date(Date, origin = \"1960-01-01\"))\n\n\n\n\n\n\n\n\n\nL’origine des dates\n\n\n\n\n\n\nEn SAS, la date de référence d’une date est le 1er janvier 1950\nEn R, la date de référence d’une date est le 1er janvier 1960\n\nLorsque l’on importe un fichier SAS en R, il faut donc bien préciser l’origine de la date dans la fonction as.Date(x, origin = \"1960-01-01\").\n\n\n\n\n\n\n3 Manipuler les dates\n\nCréer une nouvelle variable prenant pour valeur le premier jour du premier mois du trimestre plutôt que le premier jour du dernier mois via la fonction months().\n\n\nCode\n... %&gt;% mutate(deb_trimestre = date - months(2))\n\n\nCalculer l’écart entre les 2 dates en jours, puis en semaines via la fonction difftime().\n\n\nCode\n... %&gt;% mutate(diff_jour = difftime(date, deb_trimestre, units = \"days\"),\n           diff_week = difftime(date, deb_trimestre, units = \"weeks\"))\n\n\nCalculer la date de fin de trimestre.\n\n\nCode\n... %&gt;% mutate(fin_trim = (date + months(1)) - 1)\n\n\nCréer une variable indiquant le trimestre via la fonction quarter().\n\n\nCode\n... %&gt;% mutate(trim = quarter(date))\n\n\nRecréer la variable trimestre au format “2016-T1”.\n\n\nCode\n... %&gt;% mutate(trim = quarter(date))\n\n\n\n\n\n\n4 Visualisation graphique\nDes bibliothèques graphiques sont à disposition (r-graph-gallery ou r-charts) pour trouver des templates de visualisation et le code associé.\n\nCréer un graphique simple avec la date et le nombre de demandeurs d’emploi en utilisant la fonction plot()\n\n\nCode\nplot(defm$date, defm$defmA)\n\n\nCréer une ligne simple avec la date et le nombre de demandeurs d’emploi en utilisant la fonction ggplot()\n\n\nCode\nggplot(defm, aes(x=date, y=defmA)) +\n  geom_line()\n\n\nAjouter un titre avec ggtitle().\n\n\nCode\nggplot(defm, aes(x=date, y=defmA)) +\n  geom_line()+\n  ggtitle(\"Titre\")\n\n\nAjouter une seconde courbe, par exemple celle de l’ensemble des demandeurs d’emploi inscrits en catégories A, B ou C.\n\n\nCode\nggplot(defm) +\n  geom_line(aes(x=date, y=defmA))+\n  geom_line(aes(x=date, y=defmABC))+\n  ggtitle(\"Titre\")\n\n\nCréer un barlpot avec la spécification geom_bar().\n\n\nCode\nggplot(defm, aes(x=date, y=defmA)) + \n  geom_bar(stat = \"identity\")\n\n\nCréer un histograme avec la spécification geom_histogram().\n\n\nCode\nggplot(defm, aes(x=defmA)) +\n  geom_histogram()",
    "crumbs": [
      "Exercice 4"
    ]
  },
  {
    "objectID": "exercice_3.html",
    "href": "exercice_3.html",
    "title": "Exercice 3 : Statistiques descriptives",
    "section": "",
    "text": "Nous avons précédemment créé une base de travail propre permettant d’en retirer des statistiques descriptives. Celles-ci peuvent être calculées de façon à résumer le dataframe ou bien être intégrées à celui-ci via une variable supplémentaire.\n\n1 Commencer un programme\n\nCréer un nouveau programme puis l’enregister dans le projet créé précedemment.\nCharger les packages dplyr, lubridate, tidyr.\n\n\nCode\n#install.packages(\"ggplot\") # Permet d'installer le package si besoin\nlibrary(dplyr)\nlibrary(lubridate) # Package de gestion des dates\nlibrary(tidyr)\nlibrary(Hmisc)\n\n\nImporter le dataframe précédemment enregistré au format .xlsx.\n\n\nCode\ndf_final &lt;- read.xlsx(\"df.xlsx\") # Chargement du dataframe\n\n\n\n\n\n\n2 Produire des statistiques descriptives pour résumer ses données\nNos données sont désormais propres, on peut donc commencer à faire des statistiques descriptives par catégorie.\n\nConnaitre les statistiques descriptives du dataframe avec summary().\n\n\nCode\nsummary(df_final) # Permet de connaitre les statistiques descriptives des variables du dataframe\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nLa fonction summary() utilisée ici ne tient pas compte des pondérations. Les statistiques calculées à partir de la table de l’EEC doivent être pondérées.\n\n\n\nA l’aide de pipe, faire la somme des effectifs par trimestre avec la fonction summarise().\n\n\nCode\nnb_individu &lt;- df_final %&gt;% \n  group_by(trimestre) %&gt;% \n  summarise(effectifs = sum(POIDS)) \nnb_individu\n\n\nFaire la somme des effectifs pondérés par trimestre avec la fonction wtd.table() du package Hmisc.\n\n\nCode\nwtd.table(x = df_final$TRIM, weights = df_final$POIDS)\n\n\nCalculer les effectifs par modalités de la NAF en 88 postes, en utilisant la variable Libellé pour que les résultats soient lisibles.\n\n\nCode\nnb_individu_NAF = df_final %&gt;% \n  group_by(Libellé) %&gt;% \n  summarise(effectifs = sum(POIDS))\n\n\n\n\n\n\n3 Produire des statistiques descriptives dans un dataframe exhaustif\nAuparavant, nous avons vu comment résumer un dataframe à l’aide de group_by() et summarise(). On cherche désormais à ajouter des variables agrégées dans le dataframe sans perdre l’information au niveau individuel.\n\nA partir du dataframe, ajouter une variable indiquant le nombre d’individus moyen par trimestre et statut_activite_libelle à l’aide de mutate().\n\n\nCode\n   ... %&gt;% \n  group_by(trimestre, statut_activite_libelle) %&gt;% \n  mutate(sum_actif = sum(POIDS)) %&gt;% \n  ungroup()\n\n\nAjouter ensuite une variable du nombre total d’individus sur le trimestre.\n\n\nCode\n... %&gt;% \n  group_by(trimestre) %&gt;% \n  mutate(indiv_trim = sum(POIDS, na.rm = TRUE)) \n\n\n\n\n\n\n4 Calculer le nombre de chômeurs par trimestre\n\nCréer un dataframe de résultat avec le nombre d’individus par trimestre et catégorie (statut_activite_libelle) avec la fonction group_by().\n\n\nCode\nchomage &lt;- df_final %&gt;% \n  group_by(trimestre, statut_activite_libelle) %&gt;% \n  summarise(effectif_actif_trim = sum(POIDS, na.rm = TRUE)) \n\n\nCalculer la part de chaque modalité par trimestre dans le nombre d’individus total du trimestre.\n\n\nCode\ntaux_chomage &lt;- chomage %&gt;% \n  group_by(trimestre) %&gt;% \n  mutate(effectif_total = sum(effectif_actif_trim, na.rm = TRUE)) %&gt;% \n  ungroup() %&gt;% \n  mutate(taux = (effectif_actif_trim / effectif_total)*100)\n\n\n\n\n\n\n5 Mettre en forme ses résultats\n\nCréer un dataframe avec les effectifs pondérés par statut d’activité et par trimestre avec en colonne le statut d’activité et en ligne le trimestre à l’aide de la fonction pivot_wider() (2 étapes).\n\n\nCode\ndf_eff_trim_activite &lt;- df_final %&gt;%\n  group_by(trimestre, statut_activite_libelle) %&gt;%\n  summarise(effectifs = sum(POIDS))\n\ndf_pivot &lt;- df_eff_trim_activite %&gt;% \n  pivot_wider(names_from = c(statut_activite_libelle), values_from = c(effectifs))\n\n\nFaire l’opération inverse à l’aide de la fonction pivot_longer().\n\n\nCode\ndf_unpivot &lt;- df_pivot %&gt;% \n  pivot_longer(!c(trimestre), names_to = \"statut_activite_libelle\", values_to = \"effectifs\")\n\n\n\n\n\n6 Exporter ses résultats\n\nTélécharger et charger le package xlsx.\n\n\nCode\n#install.packages(xlsx) # Installation du package\nlibrary(xlsx) # Chargement du package\n\n\nExporter le dataframe de statistique descriptive en .xlsx via la fonction write_xlsx().\n\n\nCode\nwrite_xlsx(df_pivot, \"resultat.xlsx\") # Export du fichier excel\n\n\nExporter plusieurs de ses résultats dans un seul fichier excel via list() et la fonction write_xlsx().\n\n\nCode\nliste_onglet = list(\"statut_bit\" = df_pivot,\n                \"taux_chomage\" = taux_chomage)\nwrite_xlsx(liste_onglet, \"resultat_total.xlsx\") # Export du fichier excel\n\n\nExporter ses résultats au format .csv avec write_csv2().\n\n\nCode\nwrite.csv2()",
    "crumbs": [
      "Exercice 3"
    ]
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Ressources",
    "section": "",
    "text": "De nombreuses ressources R sont disponibles en libre accès. Nous vous proposons ci-dessous une liste de ressources utiles (packages, sites, etc). Vous pourrez également trouver de nombreuses informations sur GitHub et GitLab.\n\n1 Packages thématiques\n\nggplot concernant la création de graphqiques.\nlubridate concernant la gestion des dates.\nHmisc concernant le traitement des données pondérées.\nArrow concernant le traitement des données volumineuses (fichier .parquet).\nSparlyr concernant le calcul distribué.\nRJDemetra concernant la désaisonnalisation avec Jdemetra+.\n\n\n\n2 Sites 💻\n\nutilitR : Documentation sur l’usage de R créé par l’INSEE\nR for Data Science : Leçon sur la prise en main de R\nr-graph-gallery ou r-charts : Bibliothèques de graphique sous R\nThe Epidemiologist R Handbook : Leçon sur la prise en main de R fait pour des épidémilogistes mais qui reprend la majorité des outiles utiles.\n\n\n\n3 Canaux de discussion 💬\n\nTchap Dares\nTchap SSM\n\n\n\n4 Outils 🧰\n\nChatGPT ou Huggingface : Agents conversationnels permettant également de répondre à des problèmes de code.\n\n\n\n\n\n\n\nImportant\n\n\n\nAttention, le secret statistique doit être respecté lorsque vous utilisez un agent conversationnel. Aucune donnée ou information identifiante ne doit être utilisée avec ces outils.",
    "crumbs": [
      "Ressources"
    ]
  }
]
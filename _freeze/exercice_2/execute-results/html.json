{
  "hash": "16eb850836b1f72a44564f2071890af9",
  "result": {
    "markdown": "---\ntitle: \"Exercice 2 : Nettoyer et enrichir les données\"\n\ncode-fold: true\n#code-tools: true\n\ntoc: true\ntoc-expand: 2\ntoc-depth: 2\nnumber-sections: true\n\ntheme :\n  light: flatly\n  dark: darkly\n---\n\n\n\nPrécédemment, nous avons vu comment se renseigner sur un objet (type, nom des colonnes, nombre d'observations) et comment enchaîner les pipes pour sélectionner, filtrer et enrichir ses données. \n\n# Créer un projet RStudio\n\n1.  Créer un nouveau projet RStudio.\n\n2. Créer un script R et l'enregistrer dans le dossier du projet.\n\n3. Copier les données de l'Enquête Emploi 2019 dans le dossier du projet RStudio, c'est-à-dire dans le même dossier que le fichier `.Rproj`.\n\n4.  Charger le package `dplyr`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #install.packages(\"dplyr\") # Installation du package si besoin\n    library(\"dplyr\") # Chargement du package : nécessaire à chaque début de session de travail dans R Studio\n    ```\n    :::\n\n\n---\n\n# Importer les données de l'Enquête emploi 2019\n1.  Importer les données `.csv` de l'Enquête emploi 2019 avec la fonction `read.csv2` et lui assigner le nom `EEC_2019`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    EEC_2019 <- read.csv2(\"FD_EEC_2019.csv\", \n                          header = TRUE, \n                          sep = \";\", \n                          quote = \"\\\"\", \n                          dec = \".\", \n                          fill = TRUE, \n                          comment.char = \"\")\n    ```\n    :::\n\n\n2.  Obtenir des informations sur le dataframe\n      -   Nombre de lignes\n      -   Nom des colonnes \n      -   Modalités de certaines variables\n      -   Type des variables \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nrow(EEC_2019) # Nombre de lignes\n    colnames(EEC_2019) # Nom des colonnes\n    str(EEC_2019) # Informations sur le dataframe et les variables\n    ```\n    :::\n\n\n---\n\n# Mettre en forme ses données \n\nOn va désormais enchaîner les opérations, il faut donc créer un dataframe et enchaîner les pipes pour obtenir notre dataframe final. \n\n1.  Créer un dataframe en gardant uniquement les variables de la liste suivante : TRIM, ANNEE, AGE5, SEXE, ACTEU, RABS, CSTOTR, HHC6, EXTRIAN, ACTIF, NAFG088UN\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_final <- EEC_2019 %>% \n      select(TRIM, \n             ANNEE, \n             AGE5, \n             SEXE, \n             ACTEU, \n             RABS, \n             CSTOTR, \n             HHC6, \n             EXTRIAN, \n             ACTIF, \n             NAFG088UN) # Garder uniquement les variables contenues dans liste_variable \n    ```\n    :::\n\n\n2.  Dans le nouveau dataframe, créer une variable `trimestre` concaténant la variable `TRIM` et `ANNEE` à l'aide de la fonction `paste0()`. Nous souhaitons obtenir une variable sous la forme \"2019-T4\".\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% mutate(trimestre = paste0(ANNEE,\"-T\",TRIM))\n    ```\n    :::\n\n\n3.  Afficher les modalités de la variable `RABS`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    unique(EEC_2019$RABS)\n    ```\n    :::\n\n\n4.  Remplacer les `NA` de la variable `RABS` par des  0 avec la fonction `replace()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% mutate(RABS = replace(RABS, is.na(RABS), 0))\n    \n    # Autre solution avec ifelse\n    ... %>% mutate(RABS = ifelse(is.na(RABS) == TRUE, 0, RABS))\n    ```\n    :::\n\n\n5.  Remplacer les `NA` de toutes les variables par des 0 avec la fonction `mutate_all()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% mutate_all( ~ replace(., is.na(.) == TRUE, 0)) # Mutate all permet de modifier toutes les variables \n    ```\n    :::\n\n\n6.  Les données de l'enquête emploi sont des données pondérées, renommer la variable `EXTRIAN` par `POIDS`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% rename(POIDS = EXTRIAN)\n    ```\n    :::\n\n\n7.  Trier les données par trimestre dans l'ordre croissant à l'aide de la fonction `arrange()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% arrange(trimestre) # Tri du dataframe en fonction du trimestre\n    ```\n    :::\n\n\n---\n\n#   Créer des variables conditionnelles \n1.  A l'aide de la fonction `if_else()`, ajouter une variable `chomage` prenant la valeur \"oui\" lorsque la variable `ACTEU` prend la valeur `2`, \"non\" sinon.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% mutate(chomage = if_else(ACTEU == \"2\", \"oui\", \"non\"))\n    ```\n    :::\n\n\n2.  A l'aide de la fonction `case_when()`, créer une variable `statut_activite_libelle` prenant les modalités ci-dessous :\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% mutate(statut_activite_libelle = case_when(ACTEU == \"0\" ~  \"Sans objet\",\n                                          ACTEU == \"1\" ~  \"Actif occupé\",\n                                          ACTEU == \"2\" ~  \"Chômeur\",\n                                          ACTEU == \"3\" ~  \"Inactif\",\n                                          TRUE ~ \"Oubli\"))\n    ```\n    :::\n\n\n| Modalité | Défintion     |\n|:--------:|:-------------:|\n| \"0\"      | Sans objet    |\n| \"1\"      | Actif occupé  |\n| \"2\"      | Chômeur       |\n| \"3\"      | Inactif       |\n\n\n:::{.callout-note title=\"Bonne pratique\"}\nLors de la création d'une variable conditionnelle avec la fonction `case_when()`, il est conseillé de systématiquement définir une **valeur par défaut** avec une dernière condition fixée à `TRUE`, qui permettra de repérer les cas \"oubliés\", non concernés par les conditions précédentes.\n:::\n\n\n---\n\n# Joindre des données \n\nNous allons désormais récupérer les intitulés de la NAF en 88 postes (variable `NAFG088UN`) à l'aide des jointures.\n\n:::callout-note\nEn copiant le fichier naf2008_liste_n2.xlsx dans le dossier du projet, on utilise les avantages des chemins relatifs et on peut ne spécifier que le nom du fichier dans l'import, sans le chemin absolu sur le disque.\n:::\n\n1.  Importer le fichier naf2008_liste_n2.xlsx via la fonction `read.xlsx()` du package `openxlsx`. Attention, les données à importer commencent à la troisième ligne du document Excel. Trouver l'option de `read.xlsx()` qui permet de le spécifier\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #install.packages(\"openxlsx) # Installation du package si nécessaire\n    library(openxlsx)\n    intitule_naf <- read.xlsx(\"naf2008_liste_n2.xlsx \",\n                              startRow = 3) \n    ```\n    :::\n\n\n2.  Créer un dataframe unique en joignant les libellés NAF via la fonction `inner_join()`. \n    Pourquoi le nombre d'observations de `df_final_inner` est inférieur à celui de `df_final` ? \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_final_inner <- df_final %>% \n      mutate(NAFG088UN = as.character(NAFG088UN)) %>%\n      inner_join(intitule_naf, by = join_by(\"NAFG088UN\" == \"Code\")) \n    ```\n    :::\n\n\n:::{.callout-tip}\nDeux conseils pour réaliser la jointure :\nLes variables permettant de réaliser la jointure ne portent pas le même nom. Il est toujours utile de regarder les exemples d'utilisation proposés dans l'aide de la fonction `?inner_join`.\nLes variables de jointure ne doivent pas obligatoirement porter le même nom, mais elles doivent être de même type pour que la jointure fonctionne. A vous de jouer pour trouver la solution !\n:::\n\n3.  Comment faire pour conserver toutes les observations de `df_final` en joingnant les libellés NAF ? Créer un nouveau data.frame qui répond à la question.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_final_left <- df_final %>% \n      mutate(NAFG088UN = as.character(NAFG088UN)) %>%\n      left_join(intitule_naf, by = join_by(\"NAFG088UN\" == \"Code\"))\n    ```\n    :::\n\n\n4.  Créer un dataframe qui correspond à la jointure de `df_final` et des libellés NAF via la fonction `full_join()`. Qu'est ce que cette jointure permet de faire ?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_final_full <- df_final %>% \n      mutate(NAFG088UN = as.character(NAFG088UN)) %>%\n      full_join(intitule_naf, by = join_by(\"NAFG088UN\" == \"Code\"))\n    ```\n    :::\n\n\n5.  Lequel de ces data frames joints avec les libellés conservieriez-vous pour une étude avec les données EEC ?\n\n::: {.callout-tip collapse=\"true\"}\n## Les principaux types de jointure\n\n-   `inner_join()` : Retourne les observations lorsque l’identifiant est présent dans les deux tables.\n\n![](images/inner_join.png)\n\n-   `left_join()` : Retourne toutes les observations de la table de gauche, même si l’identifiant n’est pas présent dans la table de droite.\n\n![](images/left_join.png)\n\n-   `right_join()` : Retourne toutes les observations de la table de droite, même si l’identifiant n’est pas présent dans la table de gauche.\n\n![](images/right_join.png)\n\n-   `fulljoin()` :  Retourne l’ensemble des observations des deux tables, même lorsque l’identifiant ne se retrouve que dans l’une des tables.\n\n![](images/full_join.png)\n\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Empiler ou coller des données\nAvec R, nous pouvons aussi empiler des données avec `bind_cols()` ou bien les coller entre elles avec `bind_rows()`. Cependant, nous vous conseillons d'utiliser les jointures classiques (inner_join, left_join, ...) qui permettent toutes les possibilités avec des identifiants de jointure. \n\n-   `bind_cols()` permet d'accoler 2 objets via les colonnes. Il est nécessaire que les variables et l'ordre dans lequel elles apparaissent correspondent.\n\n![](images/bind_cols.png)\n\n-   `bind_rows()` permet d'accoler 2 objets via les lignes. \n\n![](images/bind_rows.png)\n:::\n\n  \n---\n\n# Enregistrer ses données \nNous avons désormais un dataframe propre et utilisable pour créer des statistiques descriptives : le `df_final_left`.\n\n1.  Sauvegarder dans un dossier son dataframe propre au format `.xlsx` à l'aide de la fonction `write.xlsx()`. vérifier que le fichier est bien enregistré à l'endroit renseigné. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    write.xlsx(df_final_left, file = \"df.xlsx\") # Enregistrement du dataframe\n    ```\n    :::\n\n    \n2.  Charger son dataframe à l'aide de la fonction `read.xlsx()` pour vérifier que la sauvegarde est correcte.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_charge <- read.xlsx(\"df.xlsx\") # Chargement du dataframe\n    ```\n    :::\n\n\n3.  Enregister son fichier et passer à l'exercice 3.    \n\n---\n\n\n\n\n",
    "supporting": [
      "exercice_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
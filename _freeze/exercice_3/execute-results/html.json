{
  "hash": "5e375e61cd17cc3abe15fcf1c2b5b72b",
  "result": {
    "markdown": "---\ntitle: \"Exercice 3 : Statistiques descriptives\"\n\ncode-fold: true\n#code-tools: true\n\ntoc: true\ntoc-expand: 2\ntoc-depth: 2\nnumber-sections: true\n\ntheme :\n  light: flatly\n  dark: darkly\n---\n\n\nNous avons précédemment créé une base de travail propre permettant d'en retirer des statistiques descriptives. Celles-ci peuvent être calculées de façon à résumer le dataframe ou bien être intégrées à celui-ci via une variable supplémentaire.\n\n# Commencer un programme\n\n1.  Créer un nouveau programme puis l'enregister dans le projet créé précedemment.\n\n2.  Charger les packages `dplyr`, `lubridate`, `tidyr`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #install.packages(\"ggplot\") # Permet d'installer le package si besoin\n    library(\"dplyr\")\n    library(\"lubridate\") # Package de gestion des dates\n    library(\"tidyr\")\n    ```\n    :::\n\n\n3.  Importer le dataframe précédemment enregistré au format `.Rdata`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    load(\"df.Rdata\") # Chargement du dataframe\n    ```\n    :::\n\n    \n---\n\n# Produire des statistiques descriptives pour résumer ses données\n\nNos données sont désormais propres, on peut donc commencer à faire des statistiques descriptives par catégorie.\n\n1.  Connaitre les statistiques descriptives du dataframe avec `summary()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    summary(df_final) # Permet de connaitre les statistiques descriptives des variables du dataframe\n    ```\n    :::\n\n\n:::{.callout-warning}\nLa fonction `summary()` utilisée ici ne tient pas compte des pondérations. Les statistiques calculées à partir de la table de l'EEC doivent être pondérées.\n:::\n\n2.  A l'aide de pipe, faire la somme des effectifs par `trimestre` avec la fonction `summarise()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nb_individu <- df_final %>% \n      group_by(trimestre) %>% \n      summarise(individu = sum(effectif, na.rm = TRUE)) \n    ```\n    :::\n\n\n3.  Créer un dataframe avec la moyenne (`mean()`), le premier quartiles (`quantile()`) et la médiane (`median()`) du nombre d'individu en fonction de la variable `SEXE`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nb_individu_mean = df %>% \n      group_by(SEXE) %>% \n      summarise(mean = mean(effectif, na.rm = TRUE),\n            median = median(effectif, na.rm = TRUE),\n            quantile_1 = quantile(effectif, 0.25))\n    ```\n    :::\n\n\n---\n\n#   Produire des statistiques descriptives dans un dataframe exhaustif \n\nAuparavant, nous avons vu comment résumer un dataframe à l'aide de `group_by()` et `summarise()`. On cherche désormais à ajouter des variables agrégées dans le dataframe sans perdre l'information au niveau individuel. \n\n1.  A partir du dataframe, ajouter une variable indiquant le nombre d'individus moyen par `trimestre` et `defintion` à l'aide de `mutate()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% \n      group_by(trimestre, defintion) %>% \n      mutate(sum_actif = mean(effectif, na.rm = TRUE)) %>% \n      ungroup()\n    ```\n    :::\n\n\n2.  Ajouter ensuite une variable du nombre total d'individus sur le trimestre.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% \n      group_by(trimestre, definition) %>% \n      mutate(indiv = sum(effectif, na.rm = TRUE)) \n    ```\n    :::\n\n\n---\n\n# Calculer le nombre de chômeurs par trimestre\n1.  Créer un dataframe de résultat avec le nombre d'individus par `trimestre` et catégorie (`defintiion`) avec la fonction `group_by()`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    chomage <- df_final %>% \n      group_by(trimestre, definition) %>% \n      summarise(effectif_actif_trim = sum(effectif, na.rm = TRUE)) \n    ```\n    :::\n\n    \n2.  Calculer la part de chaque modalité par trimestre dans le nombre d'individus total. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    taux_chomage <- chomage %>% \n      group_by(trimestre) %>% \n      mutate(effectif_total = sum(effectif, na.rm = TRUE)) %>% \n      ungroup() %>% \n      mutate(taux = (effectif_actif_trim / effectif_total)*100)\n    ```\n    :::\n\n\n---\n\n# Mettre en forme ses résultats \n\n1.  Créer un dataframe avec le nombre d'individus en ayant une colonne par définition à l'aide de la fonction `pivot_wider()`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_pivot <- nb_individu_trim_definition %>% \n      pivot_wider(names_from = c(ACTEU,definition), values_from = c(effectif,taux))\n    ```\n    :::\n\n\n2.  Faire l'opération inverse à l'aide de la fonction `pivot_longer()`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_unpivot <- df_pivot %>% \n      pivot_longer(!c(trimestre), names_to = \"definition\", values_to = \"effectif\")\n    ```\n    :::\n\n\n# Exporter ses résultats\n\n1.  Télécharger et charger le package `xlsx`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    install.packages(xlsx) # Installation du package\n    library(xlsx) # Chargement du package\n    ```\n    :::\n\n\n2.  Exporter le dataframe de statistique descriptive en `.xlsx` via la fonction `write_xlsx()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    write_xlsx(df_pivot, \"resultat.xlsx\") # Export du fichier excel\n    ```\n    :::\n\n\n3.  Exporter plusieurs de ses résultats dans un seul fichier excel via `list()` et la fonction `write_xlsx()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    liste_onglet = list(\"statut_bit\" = df_pivot,\n                    \"taux_chomage\" = taux_chomage)\n    write_xlsx(liste_onglet, \"resultat_total.xlsx\") # Export du fichier excel\n    ```\n    :::\n\n\n4.  Exporter ses résultats au format .csv avec `write_csv2()` ainsi qu'au format `.Rdata`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    write.csv2()\n    save(df_pivot, file = \"df_pivot.Rdata\")\n    ```\n    :::\n",
    "supporting": [
      "exercice_3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
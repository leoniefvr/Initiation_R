{
  "hash": "5d4aa63808c83bae0ed1eead598da002",
  "result": {
    "markdown": "---\ntitle: \"Exercice 3 : Statistiques descriptives\"\n\ncode-fold: true\n#code-tools: true\n\ntoc: true\ntoc-expand: 2\ntoc-depth: 2\nnumber-sections: true\n\ntheme :\n  light: flatly\n  dark: darkly\n---\n\n\nNous avons précédemment créé une base de travail propre permettant d'en retirer des statistiques descriptives. Celles-ci peuvent être calculées de façon à résumer le dataframe ou bien être intégrées à celui-ci via une variable supplémentaire.\n\n# Commencer un programme\n\n1.  Créer un nouveau programme puis l'enregister dans le projet créé précedemment.\n\n2.  Charger les packages `dplyr`, `lubridate`, `tidyr`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #install.packages(\"ggplot\") # Permet d'installer le package si besoin\n    library(dplyr)\n    library(lubridate) # Package de gestion des dates\n    library(tidyr)\n    library(Hmisc)\n    ```\n    :::\n\n\n3.  Importer le dataframe précédemment enregistré au format `.xlsx`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_final <- read.xlsx(\"df.xlsx\") # Chargement du dataframe\n    ```\n    :::\n\n    \n---\n\n# Produire des statistiques descriptives pour résumer ses données\n\nNos données sont désormais propres, on peut donc commencer à faire des statistiques descriptives par catégorie.\n\n1.  Connaitre les statistiques descriptives du dataframe avec `summary()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    summary(df_final) # Permet de connaitre les statistiques descriptives des variables du dataframe\n    ```\n    :::\n\n\n:::{.callout-warning}\nLa fonction `summary()` utilisée ici ne tient pas compte des pondérations. Les statistiques calculées à partir de la table de l'EEC doivent être pondérées.\n:::\n\n2.  A l'aide de pipe, faire la somme des effectifs par `trimestre` avec la fonction `summarise()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nb_individu <- df_final %>% \n      group_by(trimestre) %>% \n      summarise(effectifs = sum(POIDS)) \n    nb_individu\n    ```\n    :::\n\n\n3.  Faire la somme des effectifs pondérés par `trimestre` avec la fonction `wtd.table()` du package `Hmisc`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    wtd.table(x = df_final$TRIM, weights = df_final$POIDS)\n    ```\n    :::\n\n\n4.  Calculer les effectifs par modalités de la NAF en 88 postes, en utilisant la variable `Libellé` pour que les résultats soient lisibles.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nb_individu_NAF = df_final %>% \n      group_by(Libellé) %>% \n      summarise(effectifs = sum(POIDS))\n    ```\n    :::\n\n\n---\n\n#   Produire des statistiques descriptives dans un dataframe exhaustif \n\nAuparavant, nous avons vu comment résumer un dataframe à l'aide de `group_by()` et `summarise()`. On cherche désormais à ajouter des variables agrégées dans le dataframe sans perdre l'information au niveau individuel. \n\n1.  A partir du dataframe, ajouter une variable indiquant le nombre d'individus moyen par `trimestre` et `statut_activite_libelle` à l'aide de `mutate()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n       ... %>% \n      group_by(trimestre, statut_activite_libelle) %>% \n      mutate(sum_actif = sum(POIDS)) %>% \n      ungroup()\n    ```\n    :::\n\n\n2.  Ajouter ensuite une variable du nombre total d'individus sur le trimestre.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ... %>% \n      group_by(trimestre) %>% \n      mutate(indiv_trim = sum(POIDS, na.rm = TRUE)) \n    ```\n    :::\n\n\n---\n\n# Calculer le nombre de chômeurs par trimestre\n1.  Créer un dataframe de résultat avec le nombre d'individus par `trimestre` et catégorie (`statut_activite_libelle`) avec la fonction `group_by()`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    chomage <- df_final %>% \n      group_by(trimestre, statut_activite_libelle) %>% \n      summarise(effectif_actif_trim = sum(POIDS, na.rm = TRUE)) \n    ```\n    :::\n\n    \n2.  Calculer la part de chaque modalité par trimestre dans le nombre d'individus total du trimestre. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    taux_chomage <- chomage %>% \n      group_by(trimestre) %>% \n      mutate(effectif_total = sum(effectif_actif_trim, na.rm = TRUE)) %>% \n      ungroup() %>% \n      mutate(taux = (effectif_actif_trim / effectif_total)*100)\n    ```\n    :::\n\n\n---\n\n# Mettre en forme ses résultats \n\n1.  Créer un dataframe avec les effectifs pondérés par statut d'activité et par trimestre avec en colonne le statut d'activité et en ligne le trimestre à l'aide de la fonction `pivot_wider()` (2 étapes). \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_eff_trim_activite <- df_final %>%\n      group_by(trimestre, statut_activite_libelle) %>%\n      summarise(effectifs = sum(POIDS))\n    \n    df_pivot <- df_eff_trim_activite %>% \n      pivot_wider(names_from = c(statut_activite_libelle), values_from = c(effectifs))\n    ```\n    :::\n\n\n2.  Faire l'opération inverse à l'aide de la fonction `pivot_longer()`. \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df_unpivot <- df_pivot %>% \n      pivot_longer(!c(trimestre), names_to = \"statut_activite_libelle\", values_to = \"effectifs\")\n    ```\n    :::\n\n\n# Exporter ses résultats\n\n1.  Télécharger et charger le package `xlsx`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #install.packages(xlsx) # Installation du package\n    library(xlsx) # Chargement du package\n    ```\n    :::\n\n\n2.  Exporter le dataframe de statistique descriptive en `.xlsx` via la fonction `write_xlsx()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    write_xlsx(df_pivot, \"resultat.xlsx\") # Export du fichier excel\n    ```\n    :::\n\n\n3.  Exporter plusieurs de ses résultats dans un seul fichier excel via `list()` et la fonction `write_xlsx()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    liste_onglet = list(\"statut_bit\" = df_pivot,\n                    \"taux_chomage\" = taux_chomage)\n    write_xlsx(liste_onglet, \"resultat_total.xlsx\") # Export du fichier excel\n    ```\n    :::\n\n\n4.  Exporter ses résultats au format .csv avec `write_csv2()`.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    write.csv2()\n    ```\n    :::\n",
    "supporting": [
      "exercice_3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
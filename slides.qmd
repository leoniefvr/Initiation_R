---
title: "Prise en main des donn√©es avec R"
format: 
  revealjs:
    slide-number: true 
    footer: "Formation R - Dares"
editor: visual
---

## Un rapide tour de table pour apprendre √† se conna√Ætre üôÇ

![](images/picture_1.jpg){fig-align="center"}

## Pourquoi R ? {.scrollable .smaller}

<br>

::: incremental
-   ‚≠ê Open source et gratuit ‚≠ê
-   üåê Harmonisation des langages au sein du SSP üåê
-   üìà Analyse statistique avanc√©e üìà
-   üå≥ Vaste √©cosyst√®me : extensions appel√©es "packages" (environ 20 000) üå≥
-   ü§ù Communaut√© importante : facilit√©s pour trouver de l'aide ü§ù
:::

## Fonctionnement de R {.scrollable .smaller}

<br>

-   R est un environnement et un langage de programmation

-   **Langage interpr√©t√©** : plus proche de notre langage que du langage machine

-   **Langage compil√©** : les commandes tap√©es sont ex√©cut√©es directement

-   **Langage objet** : on assigne une valeur √† quelque chose (`a <- 1`). Le symbole `<-` d√©signe l'assignation. Les objets sont pr√©sents dans la m√©moire vive de l'ordinateur (RAM) et l'assignation est une mani√®re d'y avoir acc√®s.

‚õî**Attention :** le symbole `=` permet √©galement l'assignation, mais c'est une tr√®s mauvaise pratique de l'utiliser comme tel. Le symbole `=` est utilis√© de pr√©f√©rence pour renseigner la valeur des arguments des fonctions dans R. Vous pourrez n√©anmoins le rencontrer parfois comme mani√®re d'assigner. ‚õî

## Les sp√©cificit√©s de R {.scrollable .smaller}

<br>

Toutes les op√©rations sont enregistr√©es dans la m√©moire vive de l'ordinateur (RAM) :

-   Cela peut poser des probl√®mes lors de la manipulation de donn√©es volumineuses.

-   En SAS, la m√©moire RAM est sollicit√©e au minimum, des fichiers temporaires sont cr√©√©s.

    |                                                                                     |
    |------------------------------------------------------------------------|
    | ‚õîImpossible de charger des donn√©es de 50GO avec un ordinateur ayant 32GO de RAM ‚õî |

    **Attention :** R distingue les minuscules et les majuscules

# Pr√©sentation de RStudio {.scrollable}

RStudio est un environnement de d√©veloppement gratuit, libre et multiplateforme pour R, un langage de programmation utilis√© pour le traitement de donn√©es et l'analyse statistique.

## La console {.scrollable .smaller}

::: columns
::: {.column width="50%"}
La **console** est un peu comme une calculatrice, elle ex√©cute mais **ne stocke pas** :

-   Entrer les commandes

-   Afficher les r√©sultats

-   Afficher les messages d'erreur

-   Ne stocke pas d'information

<br>

::: panel-tabset
### Code {.scrollable}

```{r, echo=TRUE, results='hide', eval=FALSE}
152/17
```

### R√©sultat {.scrollable}

```{r, echo=FALSE}
152/17

```
:::
:::

::: {.column width="50%"}
![](images/console_R.jpeg)
:::
:::

## L'environnement : {.scrollable .smaller}

::: columns
::: {.column width="50%"}
<br>

-   Etat de la m√©moire <br>
-   R√©pertoire des donn√©es (stockage des objets) <br>
-   Import de donn√©es en mode "clic-bouton"

```{r, echo=TRUE, results='hide', eval=FALSE}
test_environnement <- 1+1
```
:::

::: {.column width="50%"}
![](images/console_R.jpeg)
:::
:::

## Files, packages, help ... {.scrollable .smaller}

::: columns
::: {.column width="50%"}
::: panel-tabset
### Files {.scrollable}

<br>

Obtenir le chemin √† la racine de ma working directory :

```{r, echo=TRUE, results='hide', eval=FALSE}
getwd()
```

<br>

La working directory est l'endroit o√π R lit et exporte par d√©faut les fichiers.

### Plots {.scrollable}

<br>

Fen√™tre d'affichage des graphiques :

```{r, echo=TRUE, results='hide', eval=FALSE}
plot(100)
```

### Packages {.scrollable}

<br>

Permet de voir les packages install√©s et charg√©s.

```{r, echo=TRUE, results='hide', eval=FALSE}
library("existepas")
```

Permet √©galement de les installer, les mettre √† jour et les charger en clic bouton.

### Help {.scrollable}

<br>

Permet d'acc√©der √† la documentation des fonctions, ainsi qu'√† des exemples. Par exemple, je ne comprends pas la fonction `mean()` :

```{r, echo=TRUE, results='hide', eval=FALSE}
help("mean")

#ou

?mean
```

La documentation de la fonction s'affiche dans la fen√™tre Help.
:::
:::

::: {.column width="50%"}
![](images/console_R.jpeg)
:::
:::

## Utiliser l'aide {.scrollable .smaller}

<br>

Les fonctions des packages sont document√©es (de mani√®re in√©gale selon les packages...), et les **arguments** principaux de chaque fonction sont pr√©sent√©s dans l'aide, avec des exemples d'appel de la fonction.

::: {.callout-tip title="Bonne pratique"}
Lorsqu'on appelle une fonction dans R, R d√©tecte souvent automatiquement les arguments sans qu'on ait besoin de les nommer explicitement. Pour des raisons de lisibilit√© du code, il est recommand√© de les **nommer** syst√©matiquement.
:::

```{r, echo = TRUE}

un_vecteur <- c(2, 3 ,9 , 45, 10)

###Bonne pratique###
mean(x = un_vecteur)

###Mauvaise pratique###
mean(un_vecteur)

```

## L'importance des packages {.scrollable .smaller}

Pour installer un package **dans la console**, on utilise :

```{r, echo=TRUE, results='hide', eval=FALSE}
install.packages("dplyr")
```

::: callout-tip
## Bonne pratique

Ne pas laisser dans un script R (un fichier de code) l'instruction `install.packages()`, car lors de la transmission d'un script, la personne peut l'ex√©cuter par erreur alors que le package est d√©j√† install√©/√† jour sur son poste de travail.
:::

Cela permet de charger (ou mettre √† jour) le package sur disque, depuis le **CRAN**. cette instruction n√©cessite donc une connexion √† internet.

On charge ensuite le package en m√©moire vive :

```{r, echo=TRUE, results='hide', eval=FALSE}
library("dplyr")
```

-   L'installation du package n'est √† ex√©cuter **qu'une seule fois**

-   `install.packages()` permet aussi de r√©cup√©rer une version mise √† jour disponible sur le CRAN

-   Le chargement en m√©moire vive (avec `library()`) doit √™tre effectu√© au d√©but de chaque session ouverte de R pour avoir acc√®s aux fonctionnalit√©s du package.

::: callout-warning
‚õî Il existe un grand nombre de packages, mais certains sont **DEPRECATED** : leur utilisation n'est plus recommand√©e car ils ne sont plus mis √† jour et entretenus. Pour assurer la p√©rennit√© d'un programme, (cha√Æne de production), il est recommand√© de n'utiliser que des packages largemment utilis√©s, r√©guli√®rement mis √† jour et recommand√© par la communaut√© (sur UtilitR par exemple).‚õî
:::

```{r}
library(dplyr)
```

## Travailler avec les projets R Studio : qu'est-ce que c'est ? {.scrollable .smaller}

Il est recommand√© de regrouper les scripts et autres fichiers relatifs √† un m√™me "projet statistique" ou √† une m√™me cha√Æne de production √† l'aide d'un projet RStudio.

Un **projet RStudio** permet de :

-   **regrouper** les programmes et autres types de documents d'un m√™me projet ensemble ;

-   faciliter le **suivi des modifcations**, notamment avec git ;

-   favoriser la **reproductibilit√©** et la transmission des r√©glages li√©s √† un projet statistique.

En pratique, c'est un fichier `.Rproj` dans un dossier qui contient les programmes et les documents d'un m√™me projet statistique.

## Travailler avec les projets R Studio : pourquoi ? {.scrollable .smaller}

Il est recommand√© de travailler syst√©matiquement avec les projets RStudio. Un projet RStudio :

-   **centralise** les √©l√©ments d'un projet statistique et permet d'y avoir acc√®s plus facilement avec les **chemins relatifs** : dans un programme, pour faire r√©f√©rence √† un document du projet RStudio, il suffit de renseigner son nom car le r√©pertoire de travail par d√©faut d'un projet est le dossier o√π se situe le fichier `.Rproj`.

-   **am√©liore le travail collaboratif** : le principe des chemins relatifs rend le projet statistique ind√©pendant de l'arborescence de la machine sur laquelle il est h√©berg√©, et permet de d√©placer les fichiers plus facilement.

-   **favorise la** **reproductibilit√©** du projet statistique (ou de d√©veloppement, d'un package par exemple). Il facilite √©galement le travail avec **Git**. Il est facile de relier un projet RStudio √† git pour travailler collaborativement.

## Cr√©er un projet {.scrollable .smaller}

::: columns
::: {.column width="30%"}
Pour cr√©er un projet sur RStudio :

-   `File > New project`

-   Il est possible de le cr√©er dans un nouveau dossier vide `New directory` ou dans un dossier existant `Existing directory`.

-   Il est √©galement possible de le relier directement √† git `Version Control`.
:::

::: {.column width="60%"}
::: r-stack
![](images/creer_projet_rstudio.png){.fragment width="550" height="400"}

![](images/new_project_2.png){.fragment width="550" height="400"}

![](images/new_project_3.png){.fragment width="550" height="400"}
:::
:::
:::

## Ouvrir un projet (source : UtilitR) {.scrollable .smaller}

<br>

Lorsqu'on ouvre un projet RStudio :

-   une nouvelle session R s'ouvre ;

-   les sauvegardes de l'environnement sont ouvertes √† partir du fichier `.RData` si l'enregistrement a √©t√© activ√© (d√©conseill√©) ;

-   la working directory est automatiquement d√©finie dans le dossier o√π se trouve le fichier `.Rproj` ;

-   les documents ouverts au moment o√π le projet a √©t√© ferm√© pour la derni√®re fois sont restaur√©s, m√™me s'ils n'avaient pas √©t√© sauv√©s.

## Fermer un projet (voir UtilitR) {.scrollable .smaller}

<br>

D'apr√®s la [documentation UtilitR sur les bonnes pratiques](https://www.book.utilitr.org/03_fiches_thematiques/fiche_rprojects) :

Il est fortement conseill√© de d√©sactiver la sauvegarde du fichier `.RData` √† la fermeture du projet. Pour ce faire, il faut aller dans `Tools > Global Options` et rester dans l'onglet General. Chercher `Save workspace to .RData on exit:`, et choisir l'option Never.

::: {.callout-tip title="Bonne pratique"} Sauvegarder et recharger les donn√©es du projet avec le fichier `.RData` est une **tr√®s mauvaise pratique** en termes de reproductibilit√©. En effet, il se peut que les donn√©es sauvegard√©es dans le `.RData` aient subi des modifications non document√©es (par exemple via la console), ou que les instructions pr√©sentes dans les scripts du projet n'aient pas √©t√© ex√©cut√©es dans l'ordre. Dans ce cas, les donn√©es contenues dans le `.RData` peuvent ne pas √™tre coh√©rentes avec le projet, et en les utilisant vous risquez de ne pas obtenir les r√©sultats que vous voulez. :::

## Fermer un projet (voir UtilitR) {.scrollable .smaller}

::: r-stack
![](images/new_script.png){.fragment width="550" height="400"}

![](images/close_project_1.png){.fragment width="550" height="400"}

![](images/close_project_2.png){.fragment width="550" height="400"}

![](images/close_project_3.png){.fragment width="550" height="400"}
:::

## R√©diger un programme R : les bonnes pratiques {.scrollable .smaller}

<br>

Comme nous l'avons vu, la console ne permet pas de stocker un programme. Pour r√©diger un programme r√©plicable, il faut cr√©er un **script R** (fichier `.R`).

Cette formation vise √† vous proposer quelques bonnes pratiques qui permettent la transmission des programmes R, notamment ceux des cha√Ænes de production.

Ces bonnes pratiques sont inspir√©es de [Chapitre 5 Boite √† outils \| Guide des bonnes pratiques en R √† l'usage des statisticiens publics (utilitr.org)](https://www.pratiques.utilitr.org/boite-%C3%A0-outils.html).

## R√©diger un programme R : les bonnes pratiques {.scrollable .smaller}

::: panel-tabset
### Nom

-   Le **nom des scripts R** (fichiers .R) peut √™tre pr√©fix√© par sa **position dans la cha√Æne de production**.

-   Le nom des scripts R peut √™tre suffix√© par le **mill√©sime de la production**, en cas de changement par rapport √† la derni√®re production et surtout en l'absence de versionage (git).

-   Il est pr√©f√©rable que le nom des objets (script, variable dans le programme, tableau de donn√©es...) ne contiennent **pas de caract√®res sp√©ciaux, d'accent** et que les mots soient s√©par√©s par des **underscores**.

-   Pour le nom des variables et tables manipul√©es dans le code, il est recommand√© d'utiliser des **substantifs informatifs**.

-   Dans l'appel d'une **fonction**, il est recommand√© de **nommer les arguments** sp√©cifi√©s explicitement, pour favoriser la r√©plicabilit√© et la compr√©hension pour le lecteur.

### Espace et indentation

-   Il est recommand√© de retourner r√©guli√®rement √† la ligne pour rendre le code plus lisible.

-   L'**indentation** n'est pas automatique en R (contrairement √† Python), il est recommand√© d'indenter le code pour am√©liorer sa lisibilit√©. Le raccourci `CTRL + I` permet de r√©indenter une s√©lection de lignes.

-   Il est recommand√© d'ins√©rer des espaces entre les op√©rateurs : assignation `<-` ; comparaison `<` `>` `<=` `>=` `==` `!=` ; op√©rations `+` `-` `=`.

-   Pas d'espace avant ou apr√®s les parenth√®ses et crochets.

### Commentaire

-   Il est recommand√© de **commenter** le code. Un commentaire d√©bute par `#` et se termine √† la fin de la ligne, contrairement √† SAS o√π il est possible d'encadrer du texte pour le commenter enti√®rement.

-   Le commentaire doit √™tre clair et relativement court : il est pr√©f√©rable de bien nommer les objets de mani√®re informative, ainsi que les arguments des fonctions.

-   Le script peut comporter des parties d√©limit√©es par des titres en commentaires.
:::

## Importer des donn√©es {.scrollable .smaller}

```{r, echo = FALSE, include = FALSE, eval = TRUE}




```

```{r import_data, echo=FALSE, warning=FALSE, message=FALSE}
library("dplyr")

EEC_2019 <- read.table("FD_EEC_2019.csv", 
               header = TRUE, sep = ";", quote = "\"", dec = ".", fill = TRUE, comment.char = "")


```

::: panel-tabset
### Importer un fichier csv

```{r, echo=TRUE, results='hide', eval=FALSE}
EEC_2019 <- read.csv2("FD_EEC_2019.csv", 
               header = TRUE, 
               sep = ";", 
               quote = "\"", 
               dec = ".", 
               fill = TRUE, 
               comment.char = "")
```

```{r, echo=TRUE, eval=TRUE}
head(EEC_2019, 5)
```

### Importer un fichier Excel

```{r, echo=TRUE, results='hide', eval=TRUE}
library("openxlsx")

EEC_excel <- read.xlsx("FD_EEC_2019.xlsx")
```

```{r, echo=TRUE, eval=TRUE}
head(EEC_excel, 5)
```

### Importer un fichier Sas

```{r, echo=TRUE, results='hide', eval=FALSE}
library("haven")

EEC_2019_SAS <- read_sas("FD_EEC_2019.sas7bdat")
```
:::

## R : une logique vectorielle {.scrollable .smaller}

<br>

L'√©l√©ment de base de R est le vecteur `c()` :

```{r, echo = TRUE}
un_vecteur_numerique <- c(2, 6, 8, 1)
```

R utilise la logique de la **vectorisation** : les fonctions sont appliqu√©es √† *l'ensemble d'un vecteur* (ou matrice) plut√¥t que d'√™tre appliqu√©es successivement √† chacun des √©l√©ments de ce vecteur (ou de cette matrice). Cela permet une **acc√©l√©ration** du temps de calcul.

Par exemple, pour obtenir le carr√© de chacun des √©l√©ments d'un vecteur :

::: panel-tabset
### Sans vectorisation

```{r, echo=TRUE, results='hide', eval=FALSE}
x <- 1:10
for (k in seq_along(x)) {
x[k] <- x[k]**2
}
```

### Avec vectorisation

Application de la fonction carr√©e au vecteur :

```{r, echo=TRUE, results='hide', eval=FALSE}
x <- 1:10
x <- x**2
```
:::

## Les objets √©l√©mentaires et leurs types {.scrollable .smaller}

::: panel-tabset
### Num√©rique {.smaller}

Il existe deux types num√©riques en R :

-   les entiers ;

-   les flottants.

```{r, echo=TRUE}

num <- 5
class(num)

```

<br>

```{r, echo=TRUE}
num <- integer(5)
class(num)

```

### Les cha√Ænes de caract√®re {.smaller}

Une cha√Æne de caract√®re est d√©limit√©e par des quotes ou des doubles quotes. Il est recommand√© d'utiliser les **doubles quotes** syst√©matiquement.

Le nombre de caract√®res d'une cha√Æne de caract√®res est donn√© par la fonction `nchar()`.

La fonction `paste0()` permet de concat√©ner des cha√Ænes de caract√®res.

üîçRemarque : l'anti slash en R permet de g√©rer les caract√®res sp√©ciaux, dans les chemins d'acc√®s aux donn√©es, il faut donc soit les remplacer par des **slashs**, soit les doubler.üîç

```{r, echo=TRUE}

#Cr√©ation d'une cha√Æne de caract√®res
chaine <- "Oui"

#Type de la variable chaine
class(chaine)
```

<br>

```{r, echo=TRUE}
#Nombre de caract√®res de la variable
nchar(chaine)
```

<br>

```{r, echo=TRUE}
#Concat√©nation de plusieurs cha√Ænes de caract√®re
print(paste0("Les ", "cha√Ænes ", "de caract√®re ", "peuvent √™tre concat√©n√©es."))
```

<br>

üîçPour aller plus loin üîç le package `stringr` permet de traiter les cha√Ænes de caract√®re : mettre en majuscules, mettre en minuscules, extraire une sous-cha√Æne...

### Les bool√©ens

Un bool√©en peut valoir `TRUE` ou `FALSE` : c'est une variable qui indique si une condition logique est v√©rifi√©e.

::: fragment
```{r, echo = TRUE, results='hide', eval=FALSE}
# Test de l'√©galit√©
print(1 == 2)
```
:::

::: fragment
```{r, echo = FALSE,eval=TRUE}
# Test de l'√©galit√©
print(1 == 2)
```
:::

<br>

::: fragment
```{r, echo = TRUE, results='hide', eval=FALSE}
a <- ("Dares" == "Dares")
print(a)
```
:::

::: fragment
```{r, echo = FALSE, eval=TRUE}
a <- ("Dares" == "Dares")
print(a)
```
:::

<br>

::: fragment
```{r, echo = TRUE, results='hide', eval=FALSE}
# Comparaison num√©rique
print(2 < 3)
```
:::

::: fragment
```{r, echo = FALSE, eval=TRUE}
# Comparaison num√©rique
print(2 < 3)
```
:::

<br>

::: fragment
```{r, echo = TRUE, results='hide', eval=FALSE}
print(4 >= 5)
```
:::

::: fragment
```{r, echo = FALSE, eval=TRUE}
print(4 >= 5)
```
:::

<br>

::: fragment
```{r, echo = TRUE, results='hide', eval=FALSE}
b <- 3 <= 2
print(b)
```
:::

::: fragment
```{r, echo = FALSE, eval=TRUE}
b <- 3 <= 2
print(b)
```
:::

<br>

::: fragment
```{r, echo = TRUE, results='hide', eval=FALSE}
# Test de la diff√©rence
print("A" != "a")
```
:::

::: fragment
```{r, echo = FALSE, eval=TRUE}
# Test de la diff√©rence
print("A" != "a")
```
:::

‚ùó **Attention :** R est sensible √† la casse ‚ùó
:::

## Les structures de donn√©es de base en R {.scrollable .smaller}

::: panel-tabset
### Vecteurs

<br>

Un **vecteur** est une s√©quence ordonn√©e d'objets √©l√©mentaires de **m√™me type**. Les vecteurs ont un type (correspondant √† celui des objets qu'il contient) donn√© par la fonction `class()` et une longueur donn√©e par la fonction `length`.

```{r, echo=TRUE}
vecteur_num <- c(3, 18, 9)
length(vecteur_num)
```

<br>

```{r, echo=TRUE}
class(vecteur_num)
```

### Listes

<br>

Une **liste** est une s√©quence ordonn√©e, √©ventuellement h√©t√©rog√®ne, d'objets de types quelconques.

Une liste est toujours de type `list`, peu importe ce qui la compose.

```{r, echo=TRUE}

liste_divers <- list("A", 7, TRUE)
length(liste_divers)
```

<br>

```{r, echo=TRUE}
class(liste_divers)
```

<br>

```{r, echo=TRUE}
#Acc√©der aux √©l√©ments d'une liste
print(liste_divers[[1]])
```
:::

# Manipuler des donn√©es : les avantages de dplyr

## Data frames {.scrollable .smaller}

<br>

Le `data.frame` est un **tableau** sous forme d'une liste (classe list) de vecteurs qui repr√©sentent les colonnes. Les vecteurs doivent √™tre de la m√™me longueur, la longueur de chaque vecteur correspond au nombre de lignes/d'observations du tableau.

Puisque **chaque colonne est un vecteur** :

-   une colonne repr√©sente une variable d'un type unique ;

-   une colonne a un nom, celui de la variable ;

-   chaque colonne doit avoir la m√™me hauteur.

Les dimensions du data.frame sont donn√©es par la fonction `dim()`.

```{r, echo=TRUE}
#Obtenir les dimensions du tableau de l'enqu√™te emploi en continu
dim(EEC_2019)

```

## Op√©rations de base sur les data.frames : R base ou dplyr ? {.scrollable .smaller}

<br>

üëâ But : si vous rencontrez des syntaxes Rbase, les comprendre. Nous recommandons pour d√©buter d'utiliser plut√¥t les syntaxes `dplyr` pr√©sent√©es plus loin.

‚ùì Pourquoi ‚ùì

La syntaxe de `dplyr` est √† notre avis plus lisible et intuitive pour s'initier √† R, et aussi largement utilis√©e par la communaut√© des utilisateurs de R, ce qui facilite le partage de solutions.

::: callout-note
Il n'existe pas une mani√®re unique de programmer en R, et l'utilisation de Rbase pr√©sente aussi des avantages : la stabilit√© par exemple, la meilleure reproductibilit√© car n√©cessite moins de packages et de d√©pendances... Cette formation propose une mani√®re de programme utilisant plut√¥t le `tidyverse`
:::

```{r, echo = FALSE, eval = TRUE}
library(forcats)

EEC_ex <- EEC_2019 %>%
  head(30) %>%
  select(SEXE, ACTIF, COURED, AGE5, CSTOTR, NAFG004UN, AGE3, ANNEE, JOURTR) %>%
  mutate(NAFG004UN = fct_recode(NAFG004UN,
                                NULL = "")) %>%
  mutate(SEXE = as.factor(SEXE)) %>%
  mutate(SEXE = fct_recode(SEXE,
                            "Homme" = "1",
                            "Femme" = "2"))

```

## Op√©rations de base sur les data.frames : R base {.scrollable .smaller}

::: panel-tabset
### S√©lectionner des lignes

-   Obtenir le nom des lignes :

```{r, echo=TRUE}
rownames(EEC_ex)
```

<br>

-   S√©lectionner la 5√®me ligne :

```{r, echo=TRUE}
EEC_ex[5,]
```

<br>

-   S√©lectionner les lignes 10 et 35 :

```{r, echo=TRUE}
EEC_ex[c(10,35),]
```

<br>

-   S√©lectionner les lignes 3 √† 8 :

```{r, echo=TRUE}
EEC_ex[c(3:8),]
```

### S√©lectionner des colonnes

-   Conna√Ætre le nom des colonnes/variables :

```{r, echo=TRUE}
names(EEC_ex)
```

<br>

-   S√©lectionner une colonne **solution 1** : la 3√®me colonne :

```{r, echo=TRUE}
EEC_ex[, 3]
```

<br>

-   S√©lectionner une colonne **solution 2**, la variable ACTIF :

```{r, echo=TRUE}
EEC_ex["ACTIF"]
```

<br>

-   S√©lectionner une colonne **solution 3**, la variable ACTIF

```{r, echo=TRUE}
EEC_ex$ACTIF
```

<br>

-   Conna√Ætre le **type** des variables :

```{r, echo=TRUE}
class(EEC_ex$AGE3)
```

<br>

-   S√©lectionner la 3√®me ligne et les colonnes SEXE et ACTIF :

```{r, echo=TRUE}
EEC_ex[3, c("SEXE", "ACTIF")]
```
:::

## Op√©rations de base sur les data.frames : convertir des colonnes {.scrollable .smaller}

<br>

Convertir une variable num√©rique en caract√®re :

```{r, echo=TRUE}
class(EEC_ex$ANNEE)
EEC_ex$ANNEE <- as.character(EEC_ex$ANNEE)
class(EEC_ex$ANNEE)
```

<br>

Convertir une colonne caract√®re en num√©rique :

```{r, echo=TRUE}
EEC_ex$ANNEE <- as.numeric(EEC_ex$ANNEE)
class(EEC_ex$ANNEE)
```

## Les facteurs : un outil pour les variables qualitatives {.scrollable .smaller}

Le type `factor` en R permet de manipuler des **variables qualitatives**.

Le package `forcats` permet de traiter les facteurs : recoder les modalit√©s, les ordonner...

::: panel-tabset
### Convertir

```{r, echo=TRUE}
class(EEC_2019$SEXE)

#Conversion de la variable SEXE de num√©rique en facteur
EEC_2019$SEXE <- as.factor(EEC_2019$SEXE)

class(EEC_2019$SEXE)
```

### Modalit√©s

La fonction `levels()` permet de conna√Ætre l'ensemble des **modalit√©s** existantes d'un facteur (m√™me si elles ne sont plus pr√©sentes dans les donn√©es apr√®s s√©lection des lignes).

```{r, echo=TRUE}
levels(EEC_2019$SEXE)
```

### Recoder

La fonction `fct_recode()` permet de renommer les modalit√©s d'un facteur, avec la syntaxe suivante :

```{r, echo = TRUE, eval = FALSE}
nouvelle_variable <- fct_recode(ancienne_variable,
                                "Nouvelle_valeur1" = "Ancienne_valeur1",
                                "Nouvelle_valeur2" = "Ancienne_valeur2",
                                NULL = "Modalite_a_supprimer")
```

Exemple : Recodage des modalit√©s de la variable SEXE.

```{r, echo = TRUE}
library(forcats)

EEC_2019$SEXE <- fct_recode(EEC_2019$SEXE,
                            "Homme" = "1",
                            "Femme" = "2")

levels(EEC_2019$SEXE)
```
:::

## Op√©rations de base sur les data.frames : les valeurs manquantes {.scrollable .smaller}

Lorsqu'une **valeur est manquante** dans une enqu√™te par exemple, elle figure sous forme de la modalit√© `NA`, "Not Available", qui existe pour tous les types de variables.

Selon la mani√®re dont ces valeurs manquantes existent dans les donn√©es √† importer dans R, elles ne sont pas forc√©ment d√©tect√©es comme telles. Par exemple :

```{r, echo = TRUE}

test_na <- as.data.frame(
  list(
  c(1, ".", 3),
  c("A", "E", ".")
  )
  )

names(test_na) <- c("Var1", "Var2")

print(test_na)

```

Il faut les recoder en `NA` avec la fonction `fct_recode()` :

```{r, echo = TRUE}

test_na$Var1 <- as.factor(test_na$Var1)

test_na$Var1 <- fct_recode(test_na$Var1,
                           NULL = ".")

print(test_na)
```

## Les dates sous R {.scrollable .smaller}

Le format de **date** le plus courant en R est la classe `Date`. Elle correspond √† une distance par rapport √† une date origine, ce qui permet de faire des calculs (distance entre deux dates par exemple).

::: panel-tabset
### Cr√©er une date

Il est possible de cr√©er une date √† partir d'une cha√Æne de carat√®re. *Le format standard est "AAAA-MM-JJ"*, mais il est possible de sp√©cifier un autre format.

```{r, echo = TRUE}

date_1 <- as.Date("2023-01-24")

date_2 <- as.Date("12/07/2022", format = "%d/%m/%Y")

```

### Composants

Le package `lubridate` permet de traiter les dates. Il n'est pas pr√©senter davantage ici, voici simplement comment il est possible d'acc√©der aux composants d'une date avec `lubridate` :

```{r, echo = TRUE}
library(lubridate)

year(date_1)
month(date_1)
quarter(date_1)
day(date_1)
```

### Intervalle

Avec le type Date, vient la notion d'intervalle temporel, qui est √©galement un type de donn√©es √† part enti√®re. La fonction `interval()` permet de calculer des dur√©es.

```{r, echo = TRUE}
library(lubridate)

date_1 <- as.Date("2023-01-24")

date_2 <- as.Date("12/07/2022", format = "%d/%m/%Y")

intervalle <- interval(date_1, date_2)
intervalle
class(intervalle)

```
:::

## Tidyverse, dplyr et le pipe {.scrollable .smaller}

<br>

La majorit√© des utilisateurs de R utilisent un ensemble de package contenu dans le `tidyverse` , qui propose des fonctions alternatives √† Rbase. Nous vous recommandons d'utiliser le tidyverse, et en particulier le package `dplyr`, pour r√©diger vos programmes.

Avantages du tidyverse et de dplyr :

-   plus lisible, plus proche d'un langage interpr√©t√© que R base ;

-   utilis√© par la majorit√© des utilisateurs de R ;

-   stable.

```{r}
library(tidyverse)
```

## Le pipe {.scrollable .smaller}

<br>

Pour encha√Æner diff√©rentes instructions sur un data.frame, on utilise le "pipe" : `%>%`, un op√©rateur qui permet de prendre ce qu'il y a √† gauche du pipe pour l'injecter en entr√©e (argument) dans la fonction √† droite du pipe.

**Attention :** il est recommand√© de d√©finir un nouveau tableau pour enregistrer les op√©rations sur un data.frame.

Les bonnes pratiques de r√©daction d'un code sont renseign√©es dans [UtilitR - Les bonnes pratiques](https://www.pratiques.utilitr.org/r%C3%A9diger-un-script-r.html)

## S√©lectionner des colonnes {.scrollable .smaller}

<br>

**S√©lectionner** des colonnes par leur nom avec `select()` :

```{r, echo = TRUE}
#Les colonnes ann√©e et Age3
nouveau_df_1 <- EEC_ex %>%
  select(ANNEE, AGE3)

head(nouveau_df_1, 5)
```

. . .

<br>

**Supprimer** une colonne avec le `-` dans `select()` :

```{r, echo = TRUE}
#Toutes les colonnes sauf Age3
nouveau_df_2 <- EEC_ex %>%
  select(-AGE3)

head(nouveau_df_2, 5)
```

## Afficher les premi√®res lignes {.scrollable .smaller}

<br>

Avant de d√©buter une analyse, il est utile de **visualiser les premi√®res lignes** du tableau de donn√©es. C'est notamment tr√®s utile lorsque les donn√©es sont volumineuses et que l'affichage du tableau complet prend du temps.

```{r, echo = TRUE}

EEC_debut <- EEC_ex %>%
  head(5)
EEC_debut

```

## Filtrer des lignes {.scrollable .smaller}

<br>

Pour filter des lignes selon une ou plusieurs conditions, on utilise la fonction `filter()` :

::: panel-tabset
### Egalit√©

```{r, echo = TRUE}

EEC_femme <- EEC_ex %>%
  filter(SEXE == "Femme")

head(EEC_femme, 5)
```

### In√©galit√©

```{r, echo = TRUE}

EEC_moins_30 <- EEC_ex %>%
  filter(AGE5 <= 30)

head(EEC_moins_30, 5)
```

### Diff√©rence

```{r, echo = TRUE}

EEC_hors_cadres <- EEC_ex %>%
  filter(CSTOTR != 3)

head(EEC_hors_cadres, 5)
```

### Plusieurs conditions

```{r, echo = TRUE}

#Op√©rateur ET
EEC_femme_moins_30 <- EEC_ex %>%
  filter(SEXE == "femme" & AGE5 <= 30)

head(EEC_femme_moins_30, 5)

#Op√©rateur OU
EEC_femme_ou_cadre <- EEC_ex %>%
  filter(SEXE == "femme" | CSTOTR == 3)

head(EEC_femme_ou_cadre, 5)
```
:::

## Filtrer des lignes {.scrollable .smaller}

<br>

::: panel-tabset
### Inclusion dans une liste

```{r, echo = TRUE}

EEC_hors_agr <- EEC_ex %>%
  filter(NAFG004UN %in% c("ET", "EU", "EV"))

head(EEC_hors_agr, 5)

```

### Valeurs manquantes

Pour tester si une valeur est manquante, il faut utiliser la fonction `is.na()`. Le test `variable == NA` renvoie une erreur.

Pour tester qu'une valeur est bien pr√©sente, c'est la condition `!(is.na(variable))`. la syntaxe `!()` signifie "diff√©rent de", c'est-√†-dire teste la condition contraire √† ce qui est renseign√© dans les parenth√®ses.

Uniquement les lignes pour lesquelles NAFG004UN est manquante :

```{r, echo = TRUE}
EEC_CSP_na <- EEC_ex %>%
  filter(is.na(NAFG004UN))

head(EEC_CSP_na, 5)
```

<br>

Uniquement les lignes pour lesquelles NAFG004UN est renseign√©e :

```{r, echo = TRUE}
EEC_CSP_hors_na <- EEC_ex %>%
  filter(!(is.na(NAFG004UN)))

head(EEC_CSP_hors_na, 5)
```

### Valeurs distinctes

La fonction `distinct()` permet de ne s√©lectionner qu'une seule occurence de chaque combinaison des variables signal√©es.

On ne souhaite qu'une seule occurence de chaque combinaison existant dans les donn√©es des variables ANNEE et TRIM :

```{r, echo = TRUE}
EEC_periode <- EEC_2019 %>%
  distinct(ANNEE, TRIM)

head(EEC_periode, 5)
```
:::

## Cr√©er une variable {.scrollable .smaller}

::: panel-tabset
### Avec if_else

`if_else` est utilis√© pour renseigner une valeur si une condition est v√©rifi√©e, une autre sinon. La syntaxe est la suivante :

```{r, echo = TRUE, eval = FALSE}

mutate(nouvelle_variable = if_else(condition, valeur_condition_verifiee, valeur_sinon))

```

```{r, echo = TRUE}
EEC_agr <- EEC_2019 %>%
  mutate(agriculture = if_else(NAFG004UN == "ES", 1, 0))

head(EEC_agr, 5)
```

### Avec case_when

`case_when` permet de cr√©er une variable qui prend diff√©rentes modalit√©s selon plusieurs conditions √©valu√©es successivement, selon la syntaxe suivante :

```{r, echo = TRUE, eval = FALSE}

mutate(nouvelle_variable = case_when(condition1 ~ valeur1,
                                     condition2 ~ valeur2,
                                     condition3 ~ valeur3,
                                     TRUE ~ valeur_par_d√©faut))

```

Les conditions sont explor√©es successivement jusqu'√† ce qu'une d'entre elles donne `TRUE`, elles ne sont donc pas n√©cessairement exclusives l'une de l'autre. La derni√®re ligne ¬´ voiture balai ¬ª (qui n'est pas obligatoire) exploite cette fonctionnalit√© avec une condition toujours vraie qui pi√®ge tous les cas non explor√©s.

### Avec une condition

ll est √©galement possible de cr√©er directement une variable de type **bool√©en** en mentionnat uniquement la condition :

```{r, echo = TRUE, eval = FALSE}
mutate(individu_cadre = (CSTOTR == 3))
```

La nouvelle variable `individu_cadre` vaut `TRUE` lorsque CSTOTR vaut 3, `FALSE` sinon.
:::

## Modifier des variables {.scrollable .smaller}

<br>

::: panel-tabset
### Renommer une variable

```{r, echo = TRUE, eval = FALSE}
rename(nouveau_nom_var1 = ancien_nom_var1,
       nouveau_nom_var2 = ancien_nom_var2)
```

```{r, echo = TRUE}

EEC_2 <- EEC_ex %>%
  rename(AGE_3_classes = AGE3)

head(EEC_2, 5)
```

### Discr√©tiser une variable quanti

Avec `cut()`, la borne inf√©rieure est exclue, la borne sup√©rieure est incluse.

```{r, echo = TRUE}
EEC_3 <- EEC_ex %>%
  mutate(JOURTR_classe = cut(JOURTR, breaks = c(2,4)))

head(EEC_3, 5)
```
:::

## Convertir des variables {.scrollable .smaller}

Les fonctions de conversion peuvent √™tre appliqu√©es aux colonnes d'un data.frame. Il est conseill√© d'affecter √† chaque variable le type le plus proche de sa nature :

```{r, echo = TRUE}
#Conversion de la variable ENFRED en facteur et de la variable COURED en caract√®res :

EEC_2019 <- EEC_2019 %>%
  mutate(ENFRED = as.factor(ENFRED),
         COURED = as.character(COURED))
```

<br>

::: columns
::: {.column width="50%"}
**ü§î Comment recoder ? ü§î**

-   transformer les variables qualitatives en facteurs ;

-   ordonner les modalit√©s pour les variables qualitatives ordinales ;

-   convertir les variables num√©riques en num√©rique ;

-   recoder les valeurs manquantes (par exemple les caract√®res vides) ;

-   transformer les cha√Ænes de caract√®re en Date si n√©cessaire.
:::

::: {.column width="50%"}
‚ùì **Pourquoi recoder** ‚ùì

-   pour r√©aliser des statistiques descriptives plus rapidement, par exemple avec la fonction summary ;

-   pour que les fonctions √©conom√©triques d√©tectent une modalit√© de r√©f√©rence pertinente pour les variables ordinales ;

-   pour tracer des s√©ries temporelles dans le cas des dates...
:::
:::

# Statistiques descriptives

üß∞ La boite √† outil du statisticien :

## La fonction COUNT {.scrollable .smaller}

<br>

-   Connaitre le nombre de lignes d'un dataframe
    -   On peut √©galement avoir cette information dans le panneau "environnement"
-   Compter le nombre d'individus dans une table exhaustive
    -   ‚õî Ne pas utiliser pour des donn√©es √©chantillon√©es ‚õî

. . .

Ne pas calculer par exemple le nombre de ch√¥meurs au sens du BIT sans pond√©ration √† partir de l'EEC :

```{r,  echo=TRUE}
chomeurs <- EEC_2019 %>% 
  filter(ACTEU == "2") %>% 
  count()

print(paste0("Le nombre de ch√¥meurs au sens du BIT N'EST PAS ", as.character(chomeurs)))
```

## La fonction summarise {.scrollable .smaller}

<br>

Cette fonction permet d'avoir un ensemble de **statistiques descriptives** : effectif, somme, moyenne, m√©diane, quantile, min, max...

Elle est fr√©quemment utilis√©e avec l'instruction `group_by()`, qui permet d'effectuer ces calculs au sein des groupes form√©s par les modalit√©s d'une variable.

::: {.callout-tip title="Group_by"}
Pour les habitu√©s de SQL, group_by n'est pas un mot cl√© mais une **vraie fonction R** avec une entr√©e et une sortie. Le r√©sultat est une table avec les m√™mes donn√©es mais un ¬´ index ¬ª en plus disant o√π sont les observations de chaque modalit√©. La pr√©sence de cet index change le fonctionnement de plusieurs fonctions de `dplyr` en les for√ßant √† travailler par morceau.
:::

## La fonction summarise {.scrollable .smaller}

<br>

::: panel-tabset
### Effectif

La fonction `n()` permet d'obtenir les effectifs.

Calcul du nombre de personnes de 30 ans ou moins :

```{r, echo = TRUE}
eff_moins_30 <- EEC_2019 %>%
  filter(AGE3 <= 30) %>%
  summarise(eff_moins_30 = n())
eff_moins_30
```

Calcul du nombre de personnes par classe d'√¢ge en 3 classes :

```{r, echo = TRUE}
eff_age_classe <- EEC_2019 %>%
  group_by(AGE3) %>%
  summarise(eff_age3 = n())
eff_age_classe
```

Calcul du nombre de personnes par SEXE :

```{r, echo = TRUE}
eff_sexe <- EEC_2019 %>%
  group_by(SEXE) %>%
  summarise(eff_sexe = n())
eff_sexe
```

### Somme, moyenne

Les fonctions `sum()` et `mean()` peuvent √™tre utilis√©es √©galement avec `summarise()`.

::: callout-warning
**Tout calcul impliquant un `NA` restitue un `NA`** : les op√©rations, les tests, les tris. Dans les calculs statistiques (par exemple avec les fonctions appel√©es par le `summarise` de dplyr utilis√© pour faire des r√©capitulations : comptages, totaux ou autres statistiques), il y a g√©n√©ralement un argument suppl√©mentaire `na.rm` (pour "remove") qui permet de ne pas tenir compte des valeurs manquantes, mais son positionnement par d√©faut est souvent √† "faux" (FALSE, ne pas enlever les valeurs manquantes du calcul).
:::

‚ö†Ô∏è **ATTENTION** ‚ö†Ô∏è Les valeurs manquantes sont le principal point d'incompatibilit√© avec SAS et leur traitement n√©cessite de redoubler d'attention quand on convertit un programme car le fonctionnement est radicalement diff√©rent en R.

Calcul de la moyenne du nombre de jours travaill√©s par semaine par sexe :

```{r, echo = TRUE}
EEC_jourtr_sexe <- EEC_2019 %>%
  group_by(SEXE) %>%
  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))
EEC_jourtr_sexe

```

### Distribution

`summarise()` est √©galement utile pour des statistiques de distribution.

Calcul de statistiques de distribution du nombre de jours travaill√©s par semaine par classe d'√¢ge :

```{r, echo = TRUE}
EEC_jourtr_age <- EEC_2019 %>%
  group_by(AGE3) %>%
  summarise(min_jour_tr = min(JOURTR, na.rm = TRUE),
            q1_jour_tr = quantile(JOURTR, na.rm = TRUE, probs = 0.25),
            med_jour_tr = median(JOURTR, na.rm = TRUE),
            q3_jour_tr = quantile(JOURTR, na.rm = TRUE, probs = 0.75),
            max_jour_tr = max(JOURTR, na.rm = TRUE))
EEC_jourtr_age
```

### Plusieurs variables

Il est possible de renseigner plusieurs variables dans l'instruction `group_by()`. Les statistiques demand√©es dans `summarise()` sont alors calcul√©es au sein de chaque classe form√©e par le croisement des modalit√©s des deux variables.

‚ö†Ô∏è **ATTENTION** ‚ö†Ô∏è la valeur par d√©faut de l'argument `drop_last` de la fonction `summarise()` est `TRUE`, ce qui implique que le dernier niveau de regroupement (la derni√®re variable renseign√©e dans le `group_by()`) est supprim√© √† l'issue de l'application de la fonction `summarise()`. Un `warning` le pr√©cise dans la console lorsque cette fonction est utilis√©e avec plusieurs variables de regroupement.

Calcul de la moyenne de jours travaill√©s par semaine par groupe de sexe crois√© avec l'√¢ge en 3 classes :

```{r, echo = TRUE}
EEC_jourtr_sexe_age <- EEC_2019 %>%
  group_by(SEXE, AGE3) %>%
  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))
EEC_jourtr_sexe_age
```
:::

## Regrouper par cat√©gorie {.scrollable .smaller}

L'op√©rateur pipe `%>%` permet d'encha√Æner les op√©rations sur une table de donn√©es.

Il faut faire attention √† cet encha√Ænement lorsqu'on utilise l'instruction `group_by`. Cette instruction peut √™tre utilis√©e avec d'autres fonctions de `dplyr` (`filter()` et `mutate()` par exemple), mais elle ne se comporte pas de la m√™me mani√®re avec toutes les fonctions. En effet, le dernier niveau de regroupement (la derni√®re variable renseign√©e dans le `group_by()`) est supprim√© √† l'issue de l'application de la fonction `summarise()`, tandis que ce n'est pas le cas avec les fonctions `mutate()` et `filter()`.

Ainsi, il est possible d'utiliser l'instruction `ungroup()` pour rem√©dier au regroupement des observations dans la suite des op√©rations sur la table.

```{r, echo = TRUE}
ex_plusieurs_gpes <- EEC_2019 %>%
  group_by(SEXE, AGE3) %>%
  mutate(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %>%
  ungroup() %>%
  distinct(SEXE, moy_jour_tr, AGE3) %>%
  group_by(SEXE) %>%
  filter(moy_jour_tr == min(moy_jour_tr))

ex_plusieurs_gpes
```

## Trier ses donn√©es {.scrollable .smaller}

Lorsqu'on utilise un regroupement, le r√©sultat est tri√© en majeur selon ce regroupement. Si on souhaite effectuer un autre tri, il faut d√©clencher le tri avec la fonction `arrange()`. Le mot cl√© `desc` (malgr√© la syntaxe, ce n'est pas une fonction) permet de trier par ordre d√©croissant. Il est possible d'utiliser plusieurs colonnes pour le tri.

üëÅÔ∏è‚Äçüó®Ô∏è **REMARQUE** üëÅÔ∏è‚Äçüó®Ô∏è Contrairement √† SAS o√π trier est la proc√©dure la plus utilis√©e, R se charge de lui m√™me de faire les tris dont il pourrait avoir besoin. Trier n'a g√©n√©ralement un sens que pour organiser la pr√©sentation de r√©sultats.

```{r, echo = TRUE}
ex_arrange <- EEC_2019 %>%
  select(SEXE, AGE3, JOURTR) %>%
  group_by(SEXE, AGE3) %>%
  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %>%
  arrange(moy_jour_tr)
ex_arrange
```

REMARQUE : Contrairement √† SAS o√π trier est la proc√©dure la plus utilis√©e, R se charge de lui m√™me de faire les tris dont il pourrait avoir besoin. Trier n'a g√©n√©ralement un sens que pour organiser la pr√©sentation de r√©sultats.

## Connaitre le num√©ro de ligne {.scrollable .smaller}

La fonction `row_number()` permet de conna√Ætre l'ordre de classement de l'observation dans la table.

Les fonctions `first()` et `last()` permettent de r√©cup√©rer respectivement la premi√®re et la derni√®re observation d'un groupe.

```{r, echo = TRUE}
ex_arrange_2 <- EEC_2019 %>%
  select(SEXE, AGE3, JOURTR) %>%
  group_by(SEXE, AGE3) %>%
  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE)) %>%
  arrange(moy_jour_tr) %>%
  mutate(numero = row_number())
ex_arrange_2
```

## Travailler avec des donn√©es pond√©r√©es {.scrollable .smaller}

Le package `Hmisc` permet de traiter des donn√©es pond√©r√©es.

Des fonctions utilisant des pond√©rations se trouvent dans le package Hmisc, elles utilisent un argument suppl√©mentaire `weights` qui permet de passer la colonne contenant les pond√©rations. Il s'agit de :

-   `wtd.mean` : la moyenne

-   `wtd.var` : la variance (en d√©duire l'√©cart type si besoin)

-   `wtd.quantile` : un quantile, plusieurs algorithmes sont impl√©ment√©s, mais aucun ne correspond √† ce que fait SAS.

```{r, echo = TRUE}
df <- data.frame(age = c(20, 30, 40, 50, 60), poids=c(1, 1, 1, 1, 3))

library(Hmisc)

new_df <- df %>% 
  summarise(quartile1 = wtd.quantile(age,w=poids,probs=.25),
            mediane = wtd.quantile(age,w=poids,probs=.5),
            moyenne = wtd.mean(age,w=poids))
```

## Concat√©nations {.scrollable .smaller}

::: panel-tabset
### Des lignes

<br>

Mettre les lignes d'une table derri√®re les lignes d'une autre : la fonction `bind_rows()`

-   Les deux listes de colonnes peuvent ne pas √™tre strictement identiques : les donn√©es ne sont mises bout √† bout que si les noms des colonnes co√Øncident, sinon des valeurs manquantes sont g√©n√©r√©es.

-   Les colonnes peuvent √™tre dans un **ordre diff√©rent** dans les deux tables, la fonction se charge de les r√©ordonner.

-   Par contre **une colonne de m√™me nom doit avoir le m√™me type dans les deux tables** ou la concat√©nation ne se fait pas.

### Des colonnes

<br>

Mettre les colonnes d'une table √† cot√© des colonnes d'une autre : la fonction `bind_cols()`.

-   Le **nombre de lignes doit co√Øncider** dans les deux tables : c'est un garde-fou contre les erreurs de manipulation, car la fonction ne r√©alise pas une jointure mais une simple juxtaposition.

-   L'usage de cette fonction est donc **plus rare** et limit√© aux situations o√π on est absolument s√ªr d'avoir le bon nombre de lignes et des donn√©es qui sont rang√©es de la m√™me fa√ßon dans les deux tables.
:::

## Jointures {.scrollable .smaller}

::: panel-tabset
### A gauche/√† droite

<br>

::: columns
::: {.column width="70%"}
```{r, echo = TRUE, eval = FALSE}

table_jointe <- table_1 %>%
  left_join(table_2, by = c("var1_table1" = "var2_table2",
                            "var3_table1" = "var4_table2"))

```
:::

::: {.column width="30%"}
![](images/left_join.png)
:::
:::

### Interne

<br>

::: columns
::: {.column width="70%"}
```{r, echo = TRUE, eval = FALSE}

table_jointe <- table_1 %>%
  inner_join(table_2, by = c("var1_table1" = "var2_table2",
                             "var3_table1" = "var4_table2"))

```
:::

::: {.column width="30%"}
![](images/inner_join.png)
:::
:::

### Externe

<br>

::: columns
::: {.column width="70%"}
```{r, echo = TRUE, eval = FALSE}

table_jointe <- table_1 %>%
  full_join(table_2, by = c("var1_table1" = "var2_table2",
                            "var3_table1" = "var4_table2"))

```
:::

::: {.column width="30%"}
![](images/full_join.png)
:::
:::

### Anti_join

<br>

Pour r√©cup√©rer les observations de la table de gauche qui sont absentes de la table de droite.

::: columns
::: {.column width="70%"}
```{r, echo = TRUE, eval = FALSE}

table_jointe <- table_1 %>%
  anti_join(table_2, by = c("var1_table1" = "var2_table2",
                            "var3_table1" = "var4_table2"))

```
:::

::: {.column width="30%"}
![](images/anti_join.png)
:::
:::
:::

## Transpositions {.scrollable .smaller}

<br>

Pour pivoter des donn√©es, il est possible d'utiliser les fonctions `pivot_longer()` et `pivot_wider()` du package `tidyr`.

Par exemple, pour la fonction `pivot_longer()`, la syntaxe est la suivante : `pivot_longer(cols = c("Var_1_pivotee", "Var_2_pivotee"), names_to = c("nom_de_la_nouvelle_colonne"))`

```{r, echo = TRUE}

library(tidyr)

ex_pivot <- EEC_2019 %>%
  select(SEXE, AGE3, JOURTR) %>%
  group_by(SEXE, AGE3) %>%
  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE),
            med_jour_tr = median(JOURTR, na.rm = TRUE)) %>%
  ungroup() %>%
  pivot_longer(cols = c("moy_jour_tr", "med_jour_tr"), names_to = c("indicateur"))
ex_pivot

```

L'article [Les pivots expliqu√©s √† ma fille](https://od-datamining.com/knwbase/pivots_r_fille/) est particuli√®rement bien fait sur le sujet.

## Graphiques avec plot {.scrollable .smaller}

Voici une pr√©sentation succinte de quelques fonctions usuelles de Rbase permettant de faire des graphiques :

::: panel-tabset
### Barplot

```{r, echo = TRUE}

ex_barplot <- EEC_2019 %>%
  select(SEXE, JOURTR) %>%
  group_by(SEXE) %>%
  summarise(moy_jour_tr = mean(JOURTR, na.rm = TRUE))

barplot(ex_barplot$moy_jour_tr, legend.text = ex_barplot$SEXE)

```

### Hist

```{r, echo = TRUE}
ex_hist <- EEC_2019 %>%
  select(JOURTR)

hist(ex_hist$JOURTR)

```

### Plot

```{r, echo = TRUE}
data(iris)
plot(x = iris$Sepal.Length, y = iris$Sepal.Width)

```
:::

## Ressources sur ggplot2 {.scrollable .smaller}

<br>

Le package `ggplot2` permet de cr√©er des graphiques tr√®s souplement, en modifiant une grande partie des param√®tres. Il ne fait pas l'objet d'une pr√©sentation ici, mais pour s'y former, la fiche UtilitR sur le sujet [UtilitR-Ggplot2](https://www.book.utilitr.org/03_fiches_thematiques/fiche_graphiques) , ainsi que le site [R-graph-gallery](https://r-graph-gallery.com/) vous sont recommand√©s.

Enfin, pour avoir des recommandations sur les diff√©rents types de visualisation possibles selon la nature des variables √† repr√©senter, le site [From Data to Viz](https://www.data-to-viz.com/) est tr√®s utile.

# Exporter des donn√©es {.scrollable .smaller}

::: panel-tabset
### En Excel : UtilitR {.scrollable .smaller}

Pour l'exportation de donn√©es au format **xlsx**, le package `openxlsx` est √† privil√©gier car il pr√©sente de multiples options tr√®s pratiques pour personnaliser les exports.

Les [deux vignettes](https://ycphs.github.io/openxlsx/articles/Introduction.html) du package sur ce sujet apportent quelques exemples des potentialit√©s d'√©criture de classeurs xlsx. La premi√®re pr√©sente notamment l'utilisation de la fonction `write.xlsx()` et la seconde illustre quelques possibilit√©s autour de la fonction `writeData()`.

```{r, echo = TRUE}

library(dplyr)

eff_par_age <- EEC_2019 %>%
  group_by(AGE3) %>%
  summarise(eff_par_age = n())
eff_par_age

library(openxlsx)

write.xlsx(eff_par_age, file = "mon_export.xlsx", asTable = TRUE)

```

### En CSV

<br>

```{r, echo = TRUE}

eff_par_age <- EEC_2019 %>%
  group_by(AGE3) %>%
  summarise(eff_par_age = n())
eff_par_age

write.csv(x = eff_par_age, file = "monFichier.csv")
```

### En PNG

<br>

Pour exporter un graphique :

```{r, echo = TRUE}

png(filename = "mon_graphique.png", width = 500, height = 300)
hist(EEC_2019$JOURTR)
dev.off()

```
:::

# Aide pour R {.scrollable .smaller}

-   cheatsheets disponibles sur UtilitR √† avoir en local

-   utilitR

-   stackoverflow

-   issues github sur le sujet

-   forums internes : tchap Outils Stats v2, Langage R, Dares entraide Git et R

-   vos coll√®gues

-   nous

-   des ateliers th√©matiques

# Bibliographie
